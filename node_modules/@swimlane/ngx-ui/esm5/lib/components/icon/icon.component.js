import { __decorate, __metadata } from "tslib";
import { Component, Input, ChangeDetectionStrategy, ElementRef, OnChanges, OnInit, ViewEncapsulation } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { IconRegistryService } from '../../services/icon-registry/icon-registry.service';
var IconComponent = /** @class */ (function () {
    function IconComponent(http, elementRef, iconRegisteryService) {
        this.http = http;
        this.elementRef = elementRef;
        this.iconRegisteryService = iconRegisteryService;
        this.defaultPath = 'assets/svgs';
        this.fontSet = 'ngx';
    }
    Object.defineProperty(IconComponent.prototype, "svgSrc", {
        set: function (val) {
            this.loadSvg(val);
        },
        enumerable: true,
        configurable: true
    });
    IconComponent.prototype.ngOnChanges = function () {
        this.update();
    };
    IconComponent.prototype.ngOnInit = function () {
        this.update();
    };
    IconComponent.prototype.update = function () {
        if (this.fontIcon) {
            this.cssClasses = this.iconRegisteryService.get(this.fontIcon, this.fontSet);
        }
    };
    IconComponent.prototype.loadSvg = function (val) {
        var _this = this;
        var opts = { responseType: 'text' };
        this.http.get(this.defaultPath + "/" + val + ".svg", opts).subscribe(
        /* istanbul ignore next */
        function (response) {
            // get our element and clean it out
            var element = _this.elementRef.nativeElement;
            element.innerHTML = '';
            // get response and build svg element
            var parser = new DOMParser();
            var svg = parser.parseFromString(response, 'image/svg+xml');
            // insert the svg result
            element.innerHTML = svg.documentElement.outerHTML;
        }, 
        /* istanbul ignore next */
        function (err) {
            console.error(err);
        });
    };
    IconComponent.ctorParameters = function () { return [
        { type: HttpClient },
        { type: ElementRef },
        { type: IconRegistryService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], IconComponent.prototype, "fontIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], IconComponent.prototype, "alt", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], IconComponent.prototype, "defaultPath", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], IconComponent.prototype, "fontSet", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], IconComponent.prototype, "svgSrc", null);
    IconComponent = __decorate([
        Component({
            exportAs: 'ngxIcon',
            selector: 'ngx-icon',
            template: "<ng-container [ngSwitch]=\"cssClasses?.length\">\n  <ng-content *ngSwitchCase=\"\"></ng-content>\n  <ng-content *ngSwitchCase=\"0\"></ng-content>\n  <i *ngSwitchCase=\"1\" [ngClass]=\"cssClasses[0]\"></i>\n  <span *ngSwitchDefault class=\"icon-fx-stacked\">\n    <i *ngFor=\"let cssClass of cssClasses\" [ngClass]=\"cssClass\"></i>\n  </span>\n</ng-container>\n",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: ["ngx-icon svg{fill:currentColor}.icon-fx-stacked{position:relative;display:inline-block;width:1em;height:1em;line-height:1em;vertical-align:baseline}.icon-fx-stacked .ngx-icon{position:absolute;width:100%;text-align:center}"]
        }),
        __metadata("design:paramtypes", [HttpClient,
            ElementRef,
            IconRegistryService])
    ], IconComponent);
    return IconComponent;
}());
export { IconComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3dpbWxhbmUvbmd4LXVpLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvaWNvbi9pY29uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsdUJBQXVCLEVBQ3ZCLFVBQVUsRUFDVixTQUFTLEVBQ1QsTUFBTSxFQUNOLGlCQUFpQixFQUNsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFbEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sb0RBQW9ELENBQUM7QUFVekY7SUFhRSx1QkFDVSxJQUFnQixFQUNoQixVQUFzQixFQUN0QixvQkFBeUM7UUFGekMsU0FBSSxHQUFKLElBQUksQ0FBWTtRQUNoQixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBcUI7UUFiMUMsZ0JBQVcsR0FBVyxhQUFhLENBQUM7UUFDcEMsWUFBTyxHQUFXLEtBQUssQ0FBQztJQWE5QixDQUFDO0lBVkosc0JBQUksaUNBQU07YUFBVixVQUFXLEdBQVc7WUFDcEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNwQixDQUFDOzs7T0FBQTtJQVVELG1DQUFXLEdBQVg7UUFDRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDaEIsQ0FBQztJQUVELGdDQUFRLEdBQVI7UUFDRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDaEIsQ0FBQztJQUVELDhCQUFNLEdBQU47UUFDRSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQzlFO0lBQ0gsQ0FBQztJQUVELCtCQUFPLEdBQVAsVUFBUSxHQUFXO1FBQW5CLGlCQXFCQztRQXBCQyxJQUFNLElBQUksR0FBUSxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsQ0FBQztRQUMzQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBWSxJQUFJLENBQUMsV0FBVyxTQUFJLEdBQUcsU0FBTSxFQUFFLElBQUksQ0FBQyxDQUFDLFNBQVM7UUFDckUsMEJBQTBCO1FBQzFCLFVBQUMsUUFBYTtZQUNaLG1DQUFtQztZQUNuQyxJQUFNLE9BQU8sR0FBRyxLQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQztZQUM5QyxPQUFPLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztZQUV2QixxQ0FBcUM7WUFDckMsSUFBTSxNQUFNLEdBQUcsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUMvQixJQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxlQUFlLENBQUMsQ0FBQztZQUU5RCx3QkFBd0I7WUFDeEIsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQztRQUNwRCxDQUFDO1FBQ0QsMEJBQTBCO1FBQzFCLFVBQUEsR0FBRztZQUNELE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDckIsQ0FBQyxDQUNGLENBQUM7SUFDSixDQUFDOztnQkF4Q2UsVUFBVTtnQkFDSixVQUFVO2dCQUNBLG1CQUFtQjs7SUFmMUM7UUFBUixLQUFLLEVBQUU7O21EQUE2QjtJQUM1QjtRQUFSLEtBQUssRUFBRTs7OENBQWE7SUFDWjtRQUFSLEtBQUssRUFBRTs7c0RBQXFDO0lBQ3BDO1FBQVIsS0FBSyxFQUFFOztrREFBeUI7SUFHakM7UUFEQyxLQUFLLEVBQUU7OzsrQ0FHUDtJQVRVLGFBQWE7UUFSekIsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLFNBQVM7WUFDbkIsUUFBUSxFQUFFLFVBQVU7WUFDcEIscVhBQW9DO1lBRXBDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO1lBQ3JDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNOztTQUNoRCxDQUFDO3lDQWVnQixVQUFVO1lBQ0osVUFBVTtZQUNBLG1CQUFtQjtPQWhCeEMsYUFBYSxDQXVEekI7SUFBRCxvQkFBQztDQUFBLEFBdkRELElBdURDO1NBdkRZLGFBQWEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgRWxlbWVudFJlZixcbiAgT25DaGFuZ2VzLFxuICBPbkluaXQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcblxuaW1wb3J0IHsgSWNvblJlZ2lzdHJ5U2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2ljb24tcmVnaXN0cnkvaWNvbi1yZWdpc3RyeS5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIGV4cG9ydEFzOiAnbmd4SWNvbicsXG4gIHNlbGVjdG9yOiAnbmd4LWljb24nLFxuICB0ZW1wbGF0ZVVybDogJy4vaWNvbi5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL2ljb24uY29tcG9uZW50LnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgSWNvbkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25Jbml0IHtcbiAgQElucHV0KCkgZm9udEljb246IHN0cmluZyB8IHN0cmluZ1tdO1xuICBASW5wdXQoKSBhbHQ6IHN0cmluZztcbiAgQElucHV0KCkgZGVmYXVsdFBhdGg6IHN0cmluZyA9ICdhc3NldHMvc3Zncyc7XG4gIEBJbnB1dCgpIGZvbnRTZXQ6IHN0cmluZyA9ICduZ3gnO1xuXG4gIEBJbnB1dCgpXG4gIHNldCBzdmdTcmModmFsOiBzdHJpbmcpIHtcbiAgICB0aGlzLmxvYWRTdmcodmFsKTtcbiAgfVxuXG4gIGNzc0NsYXNzZXM6IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaHR0cDogSHR0cENsaWVudCxcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBpY29uUmVnaXN0ZXJ5U2VydmljZTogSWNvblJlZ2lzdHJ5U2VydmljZVxuICApIHt9XG5cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuZm9udEljb24pIHtcbiAgICAgIHRoaXMuY3NzQ2xhc3NlcyA9IHRoaXMuaWNvblJlZ2lzdGVyeVNlcnZpY2UuZ2V0KHRoaXMuZm9udEljb24sIHRoaXMuZm9udFNldCk7XG4gICAgfVxuICB9XG5cbiAgbG9hZFN2Zyh2YWw6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IG9wdHM6IGFueSA9IHsgcmVzcG9uc2VUeXBlOiAndGV4dCcgfTtcbiAgICB0aGlzLmh0dHAuZ2V0PHN0cmluZz4oYCR7dGhpcy5kZWZhdWx0UGF0aH0vJHt2YWx9LnN2Z2AsIG9wdHMpLnN1YnNjcmliZShcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICAvLyBnZXQgb3VyIGVsZW1lbnQgYW5kIGNsZWFuIGl0IG91dFxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgLy8gZ2V0IHJlc3BvbnNlIGFuZCBidWlsZCBzdmcgZWxlbWVudFxuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIGNvbnN0IHN2ZyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcocmVzcG9uc2UsICdpbWFnZS9zdmcreG1sJyk7XG5cbiAgICAgICAgLy8gaW5zZXJ0IHRoZSBzdmcgcmVzdWx0XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gc3ZnLmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICB9LFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGVyciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG4iXX0=