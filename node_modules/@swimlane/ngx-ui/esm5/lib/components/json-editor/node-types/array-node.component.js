import { __assign, __decorate, __metadata, __read, __spread, __values } from "tslib";
import { Input, EventEmitter, Output } from '@angular/core';
import { createValueForSchema, jsonSchemaDataTypes, dataTypeMap, inferType, getIcon, getCurrentType, jsonSchemaDataFormats } from '../json-editor.helper';
var ArrayNode = /** @class */ (function () {
    function ArrayNode() {
        this.required = false;
        this.modelChange = new EventEmitter();
        this.schemaChange = new EventEmitter();
        this.requiredCache = {};
        this.schemas = [];
        this.dataTypes = __spread(jsonSchemaDataTypes, jsonSchemaDataFormats);
        this.dataTypeMap = dataTypeMap;
        this._array = Array;
    }
    ArrayNode.prototype.ngOnChanges = function (changes) {
        var e_1, _a;
        if (changes.schema) {
            if (this.schema && this.schema.required) {
                try {
                    for (var _b = __values(this.schema.required), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var prop = _c.value;
                        this.requiredCache[prop] = true;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
        this.initSchemasTypeByModelValue();
        this.updateIcons();
    };
    /**
     * Updates an array item of the model and emits the change event
     * @param index
     * @param value
     */
    ArrayNode.prototype.updateArrayItem = function (index, value) {
        this.model[index] = value;
        this.modelChange.emit(this.model);
    };
    /**
     * Adds a new item to the model
     */
    ArrayNode.prototype.addArrayItem = function (dataType) {
        var schema;
        if (dataType) {
            schema = JSON.parse(JSON.stringify(__assign(__assign({}, this.schema.items), dataType.schema)));
        }
        else {
            schema = JSON.parse(JSON.stringify(this.schema.items));
        }
        if (!schema.type) {
            schema.type = 'object';
        }
        if (!schema.$meta) {
            schema.$meta = {};
        }
        if (Array.isArray(schema.type)) {
            schema.$meta.type = __spread(schema.type);
            schema.type = schema.type[0];
            schema.$meta.currentType = getCurrentType(schema);
        }
        var value = createValueForSchema(schema);
        if (value !== undefined) {
            this.model.push(value);
            this.schemas.push(schema);
        }
        this.modelChange.emit(this.model);
        this.updateIcons();
    };
    /**
     * Deletes an item from the array
     * @param index
     */
    ArrayNode.prototype.deleteArrayItem = function (index) {
        this.model.splice(index, 1);
        this.schemas.splice(index, 1);
        this.model = __spread(this.model);
        this.schemas = __spread(this.schemas);
        this.modelChange.emit(this.model);
    };
    /**
     * Track By function for the array ittierator
     * @param index
     * @param value
     */
    ArrayNode.prototype.arrayTrackBy = function (index) {
        return index;
    };
    /**
     *
     * @param property
     * @param type
     */
    ArrayNode.prototype.changeItemType = function (index, type) {
        var schema = this.schemas[index];
        var dataType = this.dataTypeMap[type];
        if (dataType) {
            delete schema.format;
            schema.type = dataType.schema.type;
            if (dataType.schema.format) {
                schema.format = dataType.schema.format;
            }
            schema.$meta.currentType = getCurrentType(schema);
        }
        var value = createValueForSchema(schema);
        this.model[index] = value;
        this.modelChange.emit(this.model);
        this.updateIcons();
    };
    /**
     * Infers the schema type for each item in the array
     */
    ArrayNode.prototype.initSchemasTypeByModelValue = function () {
        var _this = this;
        this.schemas = [];
        this.model.forEach(function (value) {
            var schema = inferType(value, _this.typeCheckOverrides);
            if (_this.schema.items) {
                schema = JSON.parse(JSON.stringify(__assign(__assign({}, _this.schema.items), schema)));
            }
            _this.schemas.push(schema);
        });
    };
    /**
     * Updates the icons in the schemas
     */
    ArrayNode.prototype.updateIcons = function () {
        var e_2, _a;
        try {
            for (var _b = __values(this.schemas), _c = _b.next(); !_c.done; _c = _b.next()) {
                var schema = _c.value;
                if (!schema.$meta) {
                    schema.$meta = {};
                }
                schema.$meta.icon = getIcon(schema);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ArrayNode.prototype, "schema", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ArrayNode.prototype, "model", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ArrayNode.prototype, "required", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ArrayNode.prototype, "expanded", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ArrayNode.prototype, "path", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ArrayNode.prototype, "errors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ArrayNode.prototype, "typeCheckOverrides", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ArrayNode.prototype, "schemaRef", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ArrayNode.prototype, "modelChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ArrayNode.prototype, "schemaChange", void 0);
    return ArrayNode;
}());
export { ArrayNode };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXktbm9kZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3dpbWxhbmUvbmd4LXVpLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvanNvbi1lZGl0b3Ivbm9kZS10eXBlcy9hcnJheS1ub2RlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUE0QixNQUFNLGVBQWUsQ0FBQztBQUV0RixPQUFPLEVBQ0wsb0JBQW9CLEVBQ3BCLG1CQUFtQixFQUNuQixXQUFXLEVBQ1gsU0FBUyxFQUNULE9BQU8sRUFDUCxjQUFjLEVBR2QscUJBQXFCLEVBQ3RCLE1BQU0sdUJBQXVCLENBQUM7QUFFL0I7SUFBQTtRQU1XLGFBQVEsR0FBWSxLQUFLLENBQUM7UUFZekIsZ0JBQVcsR0FBd0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUV0RCxpQkFBWSxHQUFtQyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBRTVFLGtCQUFhLEdBQVEsRUFBRSxDQUFDO1FBQ3hCLFlBQU8sR0FBdUIsRUFBRSxDQUFDO1FBQ2pDLGNBQVMsWUFBNkIsbUJBQW1CLEVBQUsscUJBQXFCLEVBQUU7UUFDckYsZ0JBQVcsR0FBRyxXQUFXLENBQUM7UUFFMUIsV0FBTSxHQUFHLEtBQUssQ0FBQztJQXFJakIsQ0FBQztJQW5JQywrQkFBVyxHQUFYLFVBQVksT0FBc0I7O1FBQ2hDLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtZQUNsQixJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUU7O29CQUN2QyxLQUFtQixJQUFBLEtBQUEsU0FBQSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQSxnQkFBQSw0QkFBRTt3QkFBcEMsSUFBTSxJQUFJLFdBQUE7d0JBQ2IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7cUJBQ2pD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QUM1QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNLLCtCQUFXLEdBQW5COzs7WUFDRSxLQUFxQixJQUFBLEtBQUEsU0FBQSxJQUFJLENBQUMsT0FBTyxDQUFBLGdCQUFBLDRCQUFFO2dCQUE5QixJQUFNLE1BQU0sV0FBQTtnQkFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRTtvQkFDakIsTUFBTSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7aUJBQ25CO2dCQUNELE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNyQzs7Ozs7Ozs7O0lBQ0gsQ0FBQztJQTdKRDtRQURDLEtBQUssRUFBRTs7NkNBQ2lCO0lBRWhCO1FBQVIsS0FBSyxFQUFFOzs0Q0FBYztJQUViO1FBQVIsS0FBSyxFQUFFOzsrQ0FBMkI7SUFFMUI7UUFBUixLQUFLLEVBQUU7OytDQUFtQjtJQUVsQjtRQUFSLEtBQUssRUFBRTs7MkNBQWM7SUFFYjtRQUFSLEtBQUssRUFBRTs7NkNBQWU7SUFFZDtRQUFSLEtBQUssRUFBRTs7eURBQTBCO0lBRXpCO1FBQVIsS0FBSyxFQUFFOztnREFBNkI7SUFFM0I7UUFBVCxNQUFNLEVBQUU7a0NBQWMsWUFBWTtrREFBNkI7SUFFdEQ7UUFBVCxNQUFNLEVBQUU7a0NBQWUsWUFBWTttREFBd0M7SUE0STlFLGdCQUFDO0NBQUEsQUFoS0QsSUFnS0M7U0FoS1ksU0FBUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElucHV0LCBFdmVudEVtaXR0ZXIsIE91dHB1dCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVZhbHVlRm9yU2NoZW1hLFxuICBqc29uU2NoZW1hRGF0YVR5cGVzLFxuICBkYXRhVHlwZU1hcCxcbiAgaW5mZXJUeXBlLFxuICBnZXRJY29uLFxuICBnZXRDdXJyZW50VHlwZSxcbiAgSnNvblNjaGVtYURhdGFUeXBlLFxuICBKU09ORWRpdG9yU2NoZW1hLFxuICBqc29uU2NoZW1hRGF0YUZvcm1hdHNcbn0gZnJvbSAnLi4vanNvbi1lZGl0b3IuaGVscGVyJztcblxuZXhwb3J0IGNsYXNzIEFycmF5Tm9kZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpXG4gIHNjaGVtYTogSlNPTkVkaXRvclNjaGVtYTtcblxuICBASW5wdXQoKSBtb2RlbDogYW55W107XG5cbiAgQElucHV0KCkgcmVxdWlyZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBASW5wdXQoKSBleHBhbmRlZDogYm9vbGVhbjtcblxuICBASW5wdXQoKSBwYXRoOiBzdHJpbmc7XG5cbiAgQElucHV0KCkgZXJyb3JzOiBhbnlbXTtcblxuICBASW5wdXQoKSB0eXBlQ2hlY2tPdmVycmlkZXM/OiBhbnk7XG5cbiAgQElucHV0KCkgc2NoZW1hUmVmOiBKU09ORWRpdG9yU2NoZW1hO1xuXG4gIEBPdXRwdXQoKSBtb2RlbENoYW5nZTogRXZlbnRFbWl0dGVyPGFueVtdPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBAT3V0cHV0KCkgc2NoZW1hQ2hhbmdlOiBFdmVudEVtaXR0ZXI8SlNPTkVkaXRvclNjaGVtYT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgcmVxdWlyZWRDYWNoZTogYW55ID0ge307XG4gIHNjaGVtYXM6IEpTT05FZGl0b3JTY2hlbWFbXSA9IFtdO1xuICBkYXRhVHlwZXM6IEpzb25TY2hlbWFEYXRhVHlwZVtdID0gWy4uLmpzb25TY2hlbWFEYXRhVHlwZXMsIC4uLmpzb25TY2hlbWFEYXRhRm9ybWF0c107XG4gIGRhdGFUeXBlTWFwID0gZGF0YVR5cGVNYXA7XG5cbiAgX2FycmF5ID0gQXJyYXk7XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzLnNjaGVtYSkge1xuICAgICAgaWYgKHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiB0aGlzLnNjaGVtYS5yZXF1aXJlZCkge1xuICAgICAgICAgIHRoaXMucmVxdWlyZWRDYWNoZVtwcm9wXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluaXRTY2hlbWFzVHlwZUJ5TW9kZWxWYWx1ZSgpO1xuICAgIHRoaXMudXBkYXRlSWNvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGFycmF5IGl0ZW0gb2YgdGhlIG1vZGVsIGFuZCBlbWl0cyB0aGUgY2hhbmdlIGV2ZW50XG4gICAqIEBwYXJhbSBpbmRleFxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHVwZGF0ZUFycmF5SXRlbShpbmRleDogbnVtYmVyLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5tb2RlbFtpbmRleF0gPSB2YWx1ZTtcbiAgICB0aGlzLm1vZGVsQ2hhbmdlLmVtaXQodGhpcy5tb2RlbCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBtb2RlbFxuICAgKi9cbiAgYWRkQXJyYXlJdGVtKGRhdGFUeXBlPzogSnNvblNjaGVtYURhdGFUeXBlKTogdm9pZCB7XG4gICAgbGV0IHNjaGVtYTtcbiAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgIHNjaGVtYSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoeyAuLi4odGhpcy5zY2hlbWEuaXRlbXMgYXMgb2JqZWN0KSwgLi4uZGF0YVR5cGUuc2NoZW1hIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZW1hID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnNjaGVtYS5pdGVtcykpO1xuICAgIH1cblxuICAgIGlmICghc2NoZW1hLnR5cGUpIHtcbiAgICAgIHNjaGVtYS50eXBlID0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgaWYgKCFzY2hlbWEuJG1ldGEpIHtcbiAgICAgIHNjaGVtYS4kbWV0YSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS50eXBlKSkge1xuICAgICAgc2NoZW1hLiRtZXRhLnR5cGUgPSBbLi4uc2NoZW1hLnR5cGVdO1xuICAgICAgc2NoZW1hLnR5cGUgPSBzY2hlbWEudHlwZVswXTtcbiAgICAgIHNjaGVtYS4kbWV0YS5jdXJyZW50VHlwZSA9IGdldEN1cnJlbnRUeXBlKHNjaGVtYSk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWU6IGFueSA9IGNyZWF0ZVZhbHVlRm9yU2NoZW1hKHNjaGVtYSk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tb2RlbC5wdXNoKHZhbHVlKTtcbiAgICAgIHRoaXMuc2NoZW1hcy5wdXNoKHNjaGVtYSk7XG4gICAgfVxuXG4gICAgdGhpcy5tb2RlbENoYW5nZS5lbWl0KHRoaXMubW9kZWwpO1xuICAgIHRoaXMudXBkYXRlSWNvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGl0ZW0gZnJvbSB0aGUgYXJyYXlcbiAgICogQHBhcmFtIGluZGV4XG4gICAqL1xuICBkZWxldGVBcnJheUl0ZW0oaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubW9kZWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLnNjaGVtYXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLm1vZGVsID0gWy4uLnRoaXMubW9kZWxdO1xuICAgIHRoaXMuc2NoZW1hcyA9IFsuLi50aGlzLnNjaGVtYXNdO1xuICAgIHRoaXMubW9kZWxDaGFuZ2UuZW1pdCh0aGlzLm1vZGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFjayBCeSBmdW5jdGlvbiBmb3IgdGhlIGFycmF5IGl0dGllcmF0b3JcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgYXJyYXlUcmFja0J5KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcGVydHlcbiAgICogQHBhcmFtIHR5cGVcbiAgICovXG4gIGNoYW5nZUl0ZW1UeXBlKGluZGV4OiBudW1iZXIsIHR5cGU6IHN0cmluZykge1xuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuc2NoZW1hc1tpbmRleF07XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlTWFwW3R5cGVdO1xuICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgZGVsZXRlIHNjaGVtYS5mb3JtYXQ7XG4gICAgICBzY2hlbWEudHlwZSA9IGRhdGFUeXBlLnNjaGVtYS50eXBlO1xuICAgICAgaWYgKGRhdGFUeXBlLnNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgc2NoZW1hLmZvcm1hdCA9IGRhdGFUeXBlLnNjaGVtYS5mb3JtYXQ7XG4gICAgICB9XG4gICAgICBzY2hlbWEuJG1ldGEuY3VycmVudFR5cGUgPSBnZXRDdXJyZW50VHlwZShzY2hlbWEpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlOiBhbnkgPSBjcmVhdGVWYWx1ZUZvclNjaGVtYShzY2hlbWEpO1xuICAgIHRoaXMubW9kZWxbaW5kZXhdID0gdmFsdWU7XG5cbiAgICB0aGlzLm1vZGVsQ2hhbmdlLmVtaXQodGhpcy5tb2RlbCk7XG4gICAgdGhpcy51cGRhdGVJY29ucygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZmVycyB0aGUgc2NoZW1hIHR5cGUgZm9yIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXlcbiAgICovXG4gIHByaXZhdGUgaW5pdFNjaGVtYXNUeXBlQnlNb2RlbFZhbHVlKCk6IHZvaWQge1xuICAgIHRoaXMuc2NoZW1hcyA9IFtdO1xuICAgIHRoaXMubW9kZWwuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBsZXQgc2NoZW1hID0gaW5mZXJUeXBlKHZhbHVlLCB0aGlzLnR5cGVDaGVja092ZXJyaWRlcyk7XG5cbiAgICAgIGlmICh0aGlzLnNjaGVtYS5pdGVtcykge1xuICAgICAgICBzY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHsgLi4uKHRoaXMuc2NoZW1hLml0ZW1zIGFzIG9iamVjdCksIC4uLnNjaGVtYSB9KSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2NoZW1hcy5wdXNoKHNjaGVtYSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgaWNvbnMgaW4gdGhlIHNjaGVtYXNcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlSWNvbnMoKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5zY2hlbWFzKSB7XG4gICAgICBpZiAoIXNjaGVtYS4kbWV0YSkge1xuICAgICAgICBzY2hlbWEuJG1ldGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHNjaGVtYS4kbWV0YS5pY29uID0gZ2V0SWNvbihzY2hlbWEpO1xuICAgIH1cbiAgfVxufVxuIl19