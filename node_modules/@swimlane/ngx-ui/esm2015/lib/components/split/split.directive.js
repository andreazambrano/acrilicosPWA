import { __decorate, __metadata } from "tslib";
import { Input, ContentChildren, AfterContentInit, QueryList, ElementRef, Directive, OnChanges } from '@angular/core';
import { SplitAreaDirective } from './split-area.directive';
import { SplitHandleComponent } from './split-handle.component';
import { SplitDirection } from './split-direction.enum';
import { getMinMaxPct } from './get-min-max-pct.util';
import { basisToValue } from './basis-to-value.util';
import { isPercent } from './is-percent.util';
import { resizeAreaBy } from './resize-area-by.util';
let SplitDirective = class SplitDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.direction = SplitDirection.Row;
    }
    get rowCss() {
        return this.direction === SplitDirection.Row;
    }
    get columnCss() {
        return this.direction === SplitDirection.Column;
    }
    ngAfterContentInit() {
        this.handles.forEach(d => d.drag.subscribe((ev) => this.onDrag(ev)));
        this.handles.forEach(d => d.dblclick.subscribe(() => this.onDblClick()));
        this.updateHandles();
    }
    ngOnChanges() {
        this.updateHandles();
    }
    updateHandles() {
        if (this.handles) {
            this.handles.forEach(d => (d.direction = this.direction));
        }
    }
    onDblClick() {
        const basisToPx = (this.rowCss ? this.elementRef.nativeElement.clientWidth : this.elementRef.nativeElement.clientHeight) / 100;
        const area = this.areas.first;
        /* istanbul ignore if */
        if (!area)
            return;
        const [grow, shrink, basis] = area.currentFlexBasis;
        const isPct = isPercent(basis);
        const basisValue = basisToValue(basis);
        // get basis in px and %
        const basisPx = isPct ? basisValue * basisToPx : basisValue;
        const basisPct = basisPx / basisToPx;
        // get baseBasis in percent
        const baseBasis = area.initialFlexBasis[2];
        const baseBasisPct = basisToValue(baseBasis) / (isPercent(baseBasis) ? basisToPx : 1);
        const [minBasisPct, maxBasisPct] = getMinMaxPct(area.minBasis, area.maxBasis, grow, shrink, baseBasisPct, basisToPx);
        // max and min deltas
        const deltaMin = basisPct - minBasisPct;
        const deltaMax = maxBasisPct - basisPct;
        const delta = deltaMin < deltaMax ? deltaMax : -deltaMin;
        const deltaPx = delta * basisToPx;
        this.resize(deltaPx);
    }
    onDrag({ movementX, movementY }) {
        const deltaPx = this.direction === SplitDirection.Row ? movementX : movementY;
        this.resize(deltaPx);
    }
    resize(delta) {
        const basisToPx = (this.rowCss ? this.elementRef.nativeElement.clientWidth : this.elementRef.nativeElement.clientHeight) / 100;
        const areas = this.areas.toArray();
        // for now assuming splitter is after first area
        const [first, ...rest] = areas;
        [first].forEach(area => (delta = resizeAreaBy(area, delta, basisToPx)));
        // delta is distributed left to right
        rest.forEach(area => (delta += resizeAreaBy(area, -delta, basisToPx)));
    }
};
SplitDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input('ngxSplit'),
    __metadata("design:type", Object)
], SplitDirective.prototype, "direction", void 0);
__decorate([
    ContentChildren(SplitHandleComponent, { descendants: false }),
    __metadata("design:type", QueryList)
], SplitDirective.prototype, "handles", void 0);
__decorate([
    ContentChildren(SplitAreaDirective, { descendants: false }),
    __metadata("design:type", QueryList)
], SplitDirective.prototype, "areas", void 0);
SplitDirective = __decorate([
    Directive({
        exportAs: 'ngxSplit',
        selector: '[ngxSplit]',
        host: {
            class: 'ngx-split',
            '[class.row-split]': 'rowCss',
            '[class.column-split]': 'columnCss'
        }
    }),
    __metadata("design:paramtypes", [ElementRef])
], SplitDirective);
export { SplitDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXQuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHN3aW1sYW5lL25neC11aS8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL3NwbGl0L3NwbGl0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXRILE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDdEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3JELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM5QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFXckQsSUFBYSxjQUFjLEdBQTNCLE1BQWEsY0FBYztJQWlCekIsWUFBNkIsVUFBc0I7UUFBdEIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQWhCaEMsY0FBUyxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUM7SUFnQkksQ0FBQztJQWR2RCxJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxTQUFTLEtBQUssY0FBYyxDQUFDLEdBQUcsQ0FBQztJQUMvQyxDQUFDO0lBRUQsSUFBSSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMsU0FBUyxLQUFLLGNBQWMsQ0FBQyxNQUFNLENBQUM7SUFDbEQsQ0FBQztJQVVELGtCQUFrQjtRQUNoQixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMs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QUNULFFBQVEsRUFBRSxVQUFVO1FBQ3BCLFFBQVEsRUFBRSxZQUFZO1FBQ3RCLElBQUksRUFBRTtZQUNKLEtBQUssRUFBRSxXQUFXO1lBQ2xCLG1CQUFtQixFQUFFLFFBQVE7WUFDN0Isc0JBQXNCLEVBQUUsV0FBVztTQUNwQztLQUNGLENBQUM7cUNBa0J5QyxVQUFVO0dBakJ4QyxjQUFjLENBNkYxQjtTQTdGWSxjQUFjIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5wdXQsIENvbnRlbnRDaGlsZHJlbiwgQWZ0ZXJDb250ZW50SW5pdCwgUXVlcnlMaXN0LCBFbGVtZW50UmVmLCBEaXJlY3RpdmUsIE9uQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBTcGxpdEFyZWFEaXJlY3RpdmUgfSBmcm9tICcuL3NwbGl0LWFyZWEuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNwbGl0SGFuZGxlQ29tcG9uZW50IH0gZnJvbSAnLi9zcGxpdC1oYW5kbGUuY29tcG9uZW50JztcbmltcG9ydCB7IFNwbGl0RGlyZWN0aW9uIH0gZnJvbSAnLi9zcGxpdC1kaXJlY3Rpb24uZW51bSc7XG5pbXBvcnQgeyBnZXRNaW5NYXhQY3QgfSBmcm9tICcuL2dldC1taW4tbWF4LXBjdC51dGlsJztcbmltcG9ydCB7IGJhc2lzVG9WYWx1ZSB9IGZyb20gJy4vYmFzaXMtdG8tdmFsdWUudXRpbCc7XG5pbXBvcnQgeyBpc1BlcmNlbnQgfSBmcm9tICcuL2lzLXBlcmNlbnQudXRpbCc7XG5pbXBvcnQgeyByZXNpemVBcmVhQnkgfSBmcm9tICcuL3Jlc2l6ZS1hcmVhLWJ5LnV0aWwnO1xuXG5ARGlyZWN0aXZlKHtcbiAgZXhwb3J0QXM6ICduZ3hTcGxpdCcsXG4gIHNlbGVjdG9yOiAnW25neFNwbGl0XScsXG4gIGhvc3Q6IHtcbiAgICBjbGFzczogJ25neC1zcGxpdCcsXG4gICAgJ1tjbGFzcy5yb3ctc3BsaXRdJzogJ3Jvd0NzcycsXG4gICAgJ1tjbGFzcy5jb2x1bW4tc3BsaXRdJzogJ2NvbHVtbkNzcydcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBTcGxpdERpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgnbmd4U3BsaXQnKSBkaXJlY3Rpb24gPSBTcGxpdERpcmVjdGlvbi5Sb3c7XG5cbiAgZ2V0IHJvd0NzcygpIHtcbiAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09IFNwbGl0RGlyZWN0aW9uLlJvdztcbiAgfVxuXG4gIGdldCBjb2x1bW5Dc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSBTcGxpdERpcmVjdGlvbi5Db2x1bW47XG4gIH1cblxuICBAQ29udGVudENoaWxkcmVuKFNwbGl0SGFuZGxlQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9KVxuICByZWFkb25seSBoYW5kbGVzOiBRdWVyeUxpc3Q8U3BsaXRIYW5kbGVDb21wb25lbnQ+O1xuXG4gIEBDb250ZW50Q2hpbGRyZW4oU3BsaXRBcmVhRGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9KVxuICByZWFkb25seSBhcmVhczogUXVlcnlMaXN0PFNwbGl0QXJlYURpcmVjdGl2ZT47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZXMuZm9yRWFjaChkID0+IGQuZHJhZy5zdWJzY3JpYmUoKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLm9uRHJhZyhldikpKTtcbiAgICB0aGlzLmhhbmRsZXMuZm9yRWFjaChkID0+IGQuZGJsY2xpY2suc3Vic2NyaWJlKCgpID0+IHRoaXMub25EYmxDbGljaygpKSk7XG4gICAgdGhpcy51cGRhdGVIYW5kbGVzKCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICB0aGlzLnVwZGF0ZUhhbmRsZXMoKTtcbiAgfVxuXG4gIHVwZGF0ZUhhbmRsZXMoKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcykge1xuICAgICAgdGhpcy5oYW5kbGVzLmZvckVhY2goZCA9PiAoZC5kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbikpO1xuICAgIH1cbiAgfVxuXG4gIG9uRGJsQ2xpY2soKTogdm9pZCB7XG4gICAgY29uc3QgYmFzaXNUb1B4ID1cbiAgICAgICh0aGlzLnJvd0NzcyA/IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsaWVudFdpZHRoIDogdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0KSAvIDEwMDtcblxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmFyZWFzLmZpcnN0O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFhcmVhKSByZXR1cm47XG5cbiAgICBjb25zdCBbZ3Jvdywgc2hyaW5rLCBiYXNpc10gPSBhcmVhLmN1cnJlbnRGbGV4QmFzaXM7XG4gICAgY29uc3QgaXNQY3QgPSBpc1BlcmNlbnQoYmFzaXMpO1xuICAgIGNvbnN0IGJhc2lzVmFsdWUgPSBiYXNpc1RvVmFsdWUoYmFzaXMpO1xuXG4gICAgLy8gZ2V0IGJhc2lzIGluIHB4IGFuZCAlXG4gICAgY29uc3QgYmFzaXNQeCA9IGlzUGN0ID8gYmFzaXNWYWx1ZSAqIGJhc2lzVG9QeCA6IGJhc2lzVmFsdWU7XG4gICAgY29uc3QgYmFzaXNQY3QgPSBiYXNpc1B4IC8gYmFzaXNUb1B4O1xuXG4gICAgLy8gZ2V0IGJhc2VCYXNpcyBpbiBwZXJjZW50XG4gICAgY29uc3QgYmFzZUJhc2lzID0gYXJlYS5pbml0aWFsRmxleEJhc2lzWzJdO1xuICAgIGNvbnN0IGJhc2VCYXNpc1BjdCA9IGJhc2lzVG9WYWx1ZShiYXNlQmFzaXMpIC8gKGlzUGVyY2VudChiYXNlQmFzaXMpID8gYmFzaXNUb1B4IDogMSk7XG5cbiAgICBjb25zdCBbbWluQmFzaXNQY3QsIG1heEJhc2lzUGN0XSA9IGdldE1pbk1heFBjdChcbiAgICAgIGFyZWEubWluQmFzaXMsXG4gICAgICBhcmVhLm1heEJhc2lzLFxuICAgICAgZ3JvdyxcbiAgICAgIHNocmluayxcbiAgICAgIGJhc2VCYXNpc1BjdCxcbiAgICAgIGJhc2lzVG9QeFxuICAgICk7XG5cbiAgICAvLyBtYXggYW5kIG1pbiBkZWx0YXNcbiAgICBjb25zdCBkZWx0YU1pbiA9IGJhc2lzUGN0IC0gbWluQmFzaXNQY3Q7XG4gICAgY29uc3QgZGVsdGFNYXggPSBtYXhCYXNpc1BjdCAtIGJhc2lzUGN0O1xuXG4gICAgY29uc3QgZGVsdGEgPSBkZWx0YU1pbiA8IGRlbHRhTWF4ID8gZGVsdGFNYXggOiAtZGVsdGFNaW47XG4gICAgY29uc3QgZGVsdGFQeCA9IGRlbHRhICogYmFzaXNUb1B4O1xuXG4gICAgdGhpcy5yZXNpemUoZGVsdGFQeCk7XG4gIH1cblxuICBvbkRyYWcoeyBtb3ZlbWVudFgsIG1vdmVtZW50WSB9OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgZGVsdGFQeCA9IHRoaXMuZGlyZWN0aW9uID09PSBTcGxpdERpcmVjdGlvbi5Sb3cgPyBtb3ZlbWVudFggOiBtb3ZlbWVudFk7XG4gICAgdGhpcy5yZXNpemUoZGVsdGFQeCk7XG4gIH1cblxuICByZXNpemUoZGVsdGE6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGJhc2lzVG9QeCA9XG4gICAgICAodGhpcy5yb3dDc3MgPyB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGllbnRXaWR0aCA6IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodCkgLyAxMDA7XG5cbiAgICBjb25zdCBhcmVhcyA9IHRoaXMuYXJlYXMudG9BcnJheSgpO1xuXG4gICAgLy8gZm9yIG5vdyBhc3N1bWluZyBzcGxpdHRlciBpcyBhZnRlciBmaXJzdCBhcmVhXG4gICAgY29uc3QgW2ZpcnN0LCAuLi5yZXN0XSA9IGFyZWFzO1xuICAgIFtmaXJzdF0uZm9yRWFjaChhcmVhID0+IChkZWx0YSA9IHJlc2l6ZUFyZWFCeShhcmVhLCBkZWx0YSwgYmFzaXNUb1B4KSkpO1xuXG4gICAgLy8gZGVsdGEgaXMgZGlzdHJpYnV0ZWQgbGVmdCB0byByaWdodFxuICAgIHJlc3QuZm9yRWFjaChhcmVhID0+IChkZWx0YSArPSByZXNpemVBcmVhQnkoYXJlYSwgLWRlbHRhLCBiYXNpc1RvUHgpKSk7XG4gIH1cbn1cbiJdfQ==