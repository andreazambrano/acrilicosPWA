(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/material/icon'), require('@angular/material/button')) :
    typeof define === 'function' && define.amd ? define('xunk-calendar', ['exports', '@angular/core', '@angular/common', '@angular/material/icon', '@angular/material/button'], factory) :
    (global = global || self, factory(global['xunk-calendar'] = {}, global.ng.core, global.ng.common, global.ng.material.icon, global.ng.material.button));
}(this, function (exports, core, common, icon, button) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    var XunkCalendarComponent = /** @class */ (function () {
        /** CalendarComponent */
        function XunkCalendarComponent() {
            /** Array with all the calendar data */
            this.calendar = [[]];
            /** Color for heat map */
            this.heatMapColor = '#00ff00';
            /** Color for primary */
            this.primaryColor = '#ff0000';
            /** Color for primary foreground */
            this.primaryForeground = 'white';
            /** Heatmap data */
            this.heatmap = {};
            /** Set this to false to hide month changing header */
            this.showHeader = true;
            /** Emits the new date on change */
            this.change = new core.EventEmitter();
            /** Emits the new month with date as 1 on change */
            this.monthChange = new core.EventEmitter();
            /** Constants */
            this.monthNames = [
                'January', 'February', 'March', 'April',
                'May', 'June', 'July', 'August',
                'September', 'October', 'November', 'December'
            ];
            this.dayNames = [
                'Sunday', 'Monday', 'Tuesday', 'Wednesday',
                'Thrusday', 'Friday', 'Saturday'
            ];
            /* Initialize */
            this.calendar = [];
            this.today = XunkCalendarComponent_1.getToday();
            this.openPage = __assign({}, this.today);
            this.selectedDate = __assign({}, this.today);
        }
        XunkCalendarComponent_1 = XunkCalendarComponent;
        /* Get RGB from CSS color */
        XunkCalendarComponent.parseColor = function (input) {
            var div = document.createElement('div');
            div.style.color = input;
            document.body.appendChild(div);
            var m = getComputedStyle(div).color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
            document.body.removeChild(div);
            if (m) {
                return { R: m[1], G: m[2], B: m[3] };
            }
            else {
                throw new Error('Color ' + input + ' could not be parsed.');
            }
        };
        /* Get today's date */
        XunkCalendarComponent.getToday = function () {
            var dateNow = new Date();
            return {
                date: dateNow.getDate(),
                month: dateNow.getMonth(),
                year: dateNow.getFullYear()
            };
        };
        /** Pad number with zeros */
        XunkCalendarComponent.zeropad = function (num, padlen, padchar) {
            if (padchar === void 0) { padchar = '0'; }
            var pad_char = typeof padchar !== 'undefined' ? padchar : '0';
            var pad = new Array(1 + padlen).join(pad_char);
            return (pad + num).slice(-pad.length);
        };
        XunkCalendarComponent.prototype.ngOnInit = function () {
            /* Parse colors*/
            this.RGB_HM = XunkCalendarComponent_1.parseColor(this.heatMapColor);
            this.RGB_Primary = XunkCalendarComponent_1.parseColor(this.primaryColor);
            this.RGB_Primary_FG = XunkCalendarComponent_1.parseColor(this.primaryForeground);
            /* Display initial */
            this.displayCalendar();
        };
        /**
         * Returns true if two dates are the same
         * with the date taken separately
         */
        XunkCalendarComponent.prototype.sameDate = function (date, a, b) {
            return date === b.date &&
                a.month === b.month &&
                a.year === b.year;
        };
        /** Returns true if fab! */
        XunkCalendarComponent.prototype.isFab = function (col) {
            /* Check if date is selected */
            if (this.sameDate(col, this.openPage, this.selectedDate)) {
                return 'primary';
            }
            /* No matches found */
            return '';
        };
        /** Returns 'primary' if col is today */
        XunkCalendarComponent.prototype.isToday = function (col) {
            if (this.sameDate(col, this.openPage, this.today)) {
                return 'primary';
            }
            return '';
        };
        /** Select a day in the open page */
        XunkCalendarComponent.prototype.selectDay = function (col) {
            this.selectedDate.date = col;
            this.selectedDate.month = this.openPage.month;
            this.selectedDate.year = this.openPage.year;
            this.change.emit(this.selectedDate);
        };
        /** Change the month +1 or -1 */
        XunkCalendarComponent.prototype.changeMonth = function (diff) {
            this.openPage.month += diff;
            /* See if the year switches */
            if (this.openPage.month >= 12) {
                this.openPage.month = 0;
                this.openPage.year++;
            }
            if (this.openPage.month < 0) {
                this.openPage.month = 11;
                this.openPage.year--;
            }
            /* Refresh */
            this.displayCalendar();
            /* Emit event */
            this.monthChange.emit(this.openPage);
        };
        /** Compute the calendar */
        XunkCalendarComponent.prototype.displayCalendar = function () {
            /* Generate a new object */
            var newCalendar = [[]];
            var month = this.openPage.month;
            var year = this.openPage.year;
            /* Days in next month, and day of week */
            var col = new Date(year, month, 0).getDay();
            var row = 0, counter = 1;
            var numOfDays = Number(this.getDaysOfMonth(month, year));
            /* Loop to build the calendar body */
            while (counter <= numOfDays) {
                /* When to start new line */
                if (col > 6) {
                    col = 0;
                    newCalendar[++row] = [];
                }
                /* Set the value and increment */
                newCalendar[row][col++] = counter++;
            }
            /* Set the calendar to the newly computed one */
            this.calendar = newCalendar;
        };
        /** Gets the DaysPerMonth array */
        XunkCalendarComponent.prototype.getDaysOfMonth = function (month, year) {
            /* Check leap years if February */
            if (month === 1 && this.leapYear(year)) {
                return 29;
            }
            /** Return the number of days */
            return [31, 28, 31, 30, 31, 30,
                31, 31, 30, 31, 30, 31][month];
        };
        /** Returns true if leap year */
        XunkCalendarComponent.prototype.leapYear = function (year) {
            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
        };
        /** Gets the heat map color */
        XunkCalendarComponent.prototype.getHM = function (day) {
            /* If today */
            if (this.isFab(day)) {
                return "rgb(" + this.RGB_Primary.R + ", " + this.RGB_Primary.G + ", " + this.RGB_Primary.B + ")";
            }
            /* Return heatmap color */
            var zeropad = XunkCalendarComponent_1.zeropad;
            var ind = (zeropad(this.openPage.year, 4) + zeropad(this.openPage.month + 1, 2) + zeropad(day, 2));
            if (ind in this.heatmap) {
                return "rgba(" + this.RGB_HM.R + ", " + this.RGB_HM.G + ", " + this.RGB_HM.B + ", " + this.heatmap[ind] + ")";
            }
            else {
                return 'inherit';
            }
        };
        XunkCalendarComponent.prototype.getForeground = function (day) {
            /* If today */
            if (this.isFab(day)) {
                return "rgb(" + this.RGB_Primary_FG.R + ", " + this.RGB_Primary_FG.G + ", " + this.RGB_Primary_FG.B + ")";
            }
            if (this.isToday(day)) {
                return "rgb(" + this.RGB_Primary.R + ", " + this.RGB_Primary.G + ", " + this.RGB_Primary.B + ")";
            }
            return;
        };
        var XunkCalendarComponent_1;
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], XunkCalendarComponent.prototype, "today", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], XunkCalendarComponent.prototype, "openPage", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], XunkCalendarComponent.prototype, "selectedDate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], XunkCalendarComponent.prototype, "calendar", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], XunkCalendarComponent.prototype, "heatMapColor", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], XunkCalendarComponent.prototype, "primaryColor", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], XunkCalendarComponent.prototype, "primaryForeground", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], XunkCalendarComponent.prototype, "heatmap", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], XunkCalendarComponent.prototype, "showHeader", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], XunkCalendarComponent.prototype, "change", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], XunkCalendarComponent.prototype, "monthChange", void 0);
        XunkCalendarComponent = XunkCalendarComponent_1 = __decorate([
            core.Component({
                selector: 'xunk-calendar',
                template: "<table class=\"xunk-calendar\">\n\n    <!-- Header for changing month -->\n    <tr *ngIf=\"showHeader\">\n        <!-- Previous month button -->\n        <th>\n            <button mat-icon-button (click)=\"changeMonth(-1)\">\n                <mat-icon>keyboard_arrow_left</mat-icon>\n            </button>\n        </th>\n\n        <!-- Month label -->\n        <th colspan=5>{{monthNames[openPage.month]}} {{openPage.year}}</th>\n\n        <!-- Next month button -->\n        <th>\n            <button mat-icon-button (click)=\"changeMonth(1)\">\n                <mat-icon>keyboard_arrow_right</mat-icon>\n            </button>\n        </th>\n    </tr>\n\n    <!-- Weekday headers -->\n    <tr class=\"weekday\">\n        <th>M</th>\n        <th>T</th>\n        <th>W</th>\n        <th>T</th>\n        <th>F</th>\n        <th>S</th>\n        <th>S</th>\n    </tr>\n\n    <!-- The real calendar -->\n    <tr *ngFor=\"let row of calendar\">\n        <td class=\"xunk-calendar-cell\" *ngFor=\"let col of row\">\n            <button mat-icon-button\n                    *ngIf=\"col\" class=\"xunk-calendar-day\"\n                    [style.backgroundColor]=\"getHM(col)\"\n                    [style.color]=\"getForeground(col)\"\n                    (click)=\"selectDay(col)\">\n                <span [style.fontWeight]=\"isToday(col) ? 'bold' : null\">{{col}}</span>\n            </button>\n        </td>\n    </tr>\n</table>\n",
                styles: [".xunk-calendar{width:100%}.xunk-calendar-cell{text-align:center;padding:.5vw 0}.weekday{color:#cacaca}.xunk-calendar-day{-webkit-transition:background-color .1s linear,color .1s linear;transition:background-color .1s linear,color .1s linear}@media (min-width:1000px){button{font-size:1.05em}}@media (min-width:1200px){button{font-size:1.08em}}"]
            }),
            __metadata("design:paramtypes", [])
        ], XunkCalendarComponent);
        return XunkCalendarComponent;
    }());

    var XunkCalendarModule = /** @class */ (function () {
        function XunkCalendarModule() {
        }
        /* Gets today's date */
        XunkCalendarModule.getToday = function () {
            return XunkCalendarComponent.getToday();
        };
        /** Pad number with zeros */
        XunkCalendarModule.zeroPad = function (num, padlen, padchar) {
            if (padchar === void 0) { padchar = '0'; }
            return XunkCalendarComponent.zeropad(num, padlen, padchar);
        };
        XunkCalendarModule = __decorate([
            core.NgModule({
                declarations: [
                    XunkCalendarComponent
                ],
                imports: [
                    common.CommonModule,
                    icon.MatIconModule,
                    button.MatButtonModule,
                ],
                exports: [
                    XunkCalendarComponent,
                ]
            })
        ], XunkCalendarModule);
        return XunkCalendarModule;
    }());

    exports.XunkCalendarModule = XunkCalendarModule;
    exports.ɵa = XunkCalendarComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=xunk-calendar.umd.js.map
