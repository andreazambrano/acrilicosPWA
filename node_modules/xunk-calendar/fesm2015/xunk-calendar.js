import { __decorate, __metadata } from 'tslib';
import { EventEmitter, Input, Output, Component, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';

var XunkCalendarComponent_1;
let XunkCalendarComponent = XunkCalendarComponent_1 = class XunkCalendarComponent {
    /** CalendarComponent */
    constructor() {
        /** Array with all the calendar data */
        this.calendar = [[]];
        /** Color for heat map */
        this.heatMapColor = '#00ff00';
        /** Color for primary */
        this.primaryColor = '#ff0000';
        /** Color for primary foreground */
        this.primaryForeground = 'white';
        /** Heatmap data */
        this.heatmap = {};
        /** Set this to false to hide month changing header */
        this.showHeader = true;
        /** Emits the new date on change */
        this.change = new EventEmitter();
        /** Emits the new month with date as 1 on change */
        this.monthChange = new EventEmitter();
        /** Constants */
        this.monthNames = [
            'January', 'February', 'March', 'April',
            'May', 'June', 'July', 'August',
            'September', 'October', 'November', 'December'
        ];
        this.dayNames = [
            'Sunday', 'Monday', 'Tuesday', 'Wednesday',
            'Thrusday', 'Friday', 'Saturday'
        ];
        /* Initialize */
        this.calendar = [];
        this.today = XunkCalendarComponent_1.getToday();
        this.openPage = Object.assign({}, this.today);
        this.selectedDate = Object.assign({}, this.today);
    }
    /* Get RGB from CSS color */
    static parseColor(input) {
        const div = document.createElement('div');
        div.style.color = input;
        document.body.appendChild(div);
        const m = getComputedStyle(div).color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
        document.body.removeChild(div);
        if (m) {
            return { R: m[1], G: m[2], B: m[3] };
        }
        else {
            throw new Error('Color ' + input + ' could not be parsed.');
        }
    }
    /* Get today's date */
    static getToday() {
        const dateNow = new Date();
        return {
            date: dateNow.getDate(),
            month: dateNow.getMonth(),
            year: dateNow.getFullYear()
        };
    }
    /** Pad number with zeros */
    static zeropad(num, padlen, padchar = '0') {
        const pad_char = typeof padchar !== 'undefined' ? padchar : '0';
        const pad = new Array(1 + padlen).join(pad_char);
        return (pad + num).slice(-pad.length);
    }
    ngOnInit() {
        /* Parse colors*/
        this.RGB_HM = XunkCalendarComponent_1.parseColor(this.heatMapColor);
        this.RGB_Primary = XunkCalendarComponent_1.parseColor(this.primaryColor);
        this.RGB_Primary_FG = XunkCalendarComponent_1.parseColor(this.primaryForeground);
        /* Display initial */
        this.displayCalendar();
    }
    /**
     * Returns true if two dates are the same
     * with the date taken separately
     */
    sameDate(date, a, b) {
        return date === b.date &&
            a.month === b.month &&
            a.year === b.year;
    }
    /** Returns true if fab! */
    isFab(col) {
        /* Check if date is selected */
        if (this.sameDate(col, this.openPage, this.selectedDate)) {
            return 'primary';
        }
        /* No matches found */
        return '';
    }
    /** Returns 'primary' if col is today */
    isToday(col) {
        if (this.sameDate(col, this.openPage, this.today)) {
            return 'primary';
        }
        return '';
    }
    /** Select a day in the open page */
    selectDay(col) {
        this.selectedDate.date = col;
        this.selectedDate.month = this.openPage.month;
        this.selectedDate.year = this.openPage.year;
        this.change.emit(this.selectedDate);
    }
    /** Change the month +1 or -1 */
    changeMonth(diff) {
        this.openPage.month += diff;
        /* See if the year switches */
        if (this.openPage.month >= 12) {
            this.openPage.month = 0;
            this.openPage.year++;
        }
        if (this.openPage.month < 0) {
            this.openPage.month = 11;
            this.openPage.year--;
        }
        /* Refresh */
        this.displayCalendar();
        /* Emit event */
        this.monthChange.emit(this.openPage);
    }
    /** Compute the calendar */
    displayCalendar() {
        /* Generate a new object */
        const newCalendar = [[]];
        const month = this.openPage.month;
        const year = this.openPage.year;
        /* Days in next month, and day of week */
        let col = new Date(year, month, 0).getDay();
        let row = 0, counter = 1;
        const numOfDays = Number(this.getDaysOfMonth(month, year));
        /* Loop to build the calendar body */
        while (counter <= numOfDays) {
            /* When to start new line */
            if (col > 6) {
                col = 0;
                newCalendar[++row] = [];
            }
            /* Set the value and increment */
            newCalendar[row][col++] = counter++;
        }
        /* Set the calendar to the newly computed one */
        this.calendar = newCalendar;
    }
    /** Gets the DaysPerMonth array */
    getDaysOfMonth(month, year) {
        /* Check leap years if February */
        if (month === 1 && this.leapYear(year)) {
            return 29;
        }
        /** Return the number of days */
        return [31, 28, 31, 30, 31, 30,
            31, 31, 30, 31, 30, 31][month];
    }
    /** Returns true if leap year */
    leapYear(year) {
        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
    }
    /** Gets the heat map color */
    getHM(day) {
        /* If today */
        if (this.isFab(day)) {
            return `rgb(${this.RGB_Primary.R}, ${this.RGB_Primary.G}, ${this.RGB_Primary.B})`;
        }
        /* Return heatmap color */
        const zeropad = XunkCalendarComponent_1.zeropad;
        const ind = (zeropad(this.openPage.year, 4) + zeropad(this.openPage.month + 1, 2) + zeropad(day, 2));
        if (ind in this.heatmap) {
            return `rgba(${this.RGB_HM.R}, ${this.RGB_HM.G}, ${this.RGB_HM.B}, ${this.heatmap[ind]})`;
        }
        else {
            return 'inherit';
        }
    }
    getForeground(day) {
        /* If today */
        if (this.isFab(day)) {
            return `rgb(${this.RGB_Primary_FG.R}, ${this.RGB_Primary_FG.G}, ${this.RGB_Primary_FG.B})`;
        }
        if (this.isToday(day)) {
            return `rgb(${this.RGB_Primary.R}, ${this.RGB_Primary.G}, ${this.RGB_Primary.B})`;
        }
        return;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], XunkCalendarComponent.prototype, "today", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XunkCalendarComponent.prototype, "openPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XunkCalendarComponent.prototype, "selectedDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], XunkCalendarComponent.prototype, "calendar", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XunkCalendarComponent.prototype, "heatMapColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XunkCalendarComponent.prototype, "primaryColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XunkCalendarComponent.prototype, "primaryForeground", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XunkCalendarComponent.prototype, "heatmap", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XunkCalendarComponent.prototype, "showHeader", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], XunkCalendarComponent.prototype, "change", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], XunkCalendarComponent.prototype, "monthChange", void 0);
XunkCalendarComponent = XunkCalendarComponent_1 = __decorate([
    Component({
        selector: 'xunk-calendar',
        template: "<table class=\"xunk-calendar\">\n\n    <!-- Header for changing month -->\n    <tr *ngIf=\"showHeader\">\n        <!-- Previous month button -->\n        <th>\n            <button mat-icon-button (click)=\"changeMonth(-1)\">\n                <mat-icon>keyboard_arrow_left</mat-icon>\n            </button>\n        </th>\n\n        <!-- Month label -->\n        <th colspan=5>{{monthNames[openPage.month]}} {{openPage.year}}</th>\n\n        <!-- Next month button -->\n        <th>\n            <button mat-icon-button (click)=\"changeMonth(1)\">\n                <mat-icon>keyboard_arrow_right</mat-icon>\n            </button>\n        </th>\n    </tr>\n\n    <!-- Weekday headers -->\n    <tr class=\"weekday\">\n        <th>M</th>\n        <th>T</th>\n        <th>W</th>\n        <th>T</th>\n        <th>F</th>\n        <th>S</th>\n        <th>S</th>\n    </tr>\n\n    <!-- The real calendar -->\n    <tr *ngFor=\"let row of calendar\">\n        <td class=\"xunk-calendar-cell\" *ngFor=\"let col of row\">\n            <button mat-icon-button\n                    *ngIf=\"col\" class=\"xunk-calendar-day\"\n                    [style.backgroundColor]=\"getHM(col)\"\n                    [style.color]=\"getForeground(col)\"\n                    (click)=\"selectDay(col)\">\n                <span [style.fontWeight]=\"isToday(col) ? 'bold' : null\">{{col}}</span>\n            </button>\n        </td>\n    </tr>\n</table>\n",
        styles: [".xunk-calendar{width:100%}.xunk-calendar-cell{text-align:center;padding:.5vw 0}.weekday{color:#cacaca}.xunk-calendar-day{-webkit-transition:background-color .1s linear,color .1s linear;transition:background-color .1s linear,color .1s linear}@media (min-width:1000px){button{font-size:1.05em}}@media (min-width:1200px){button{font-size:1.08em}}"]
    }),
    __metadata("design:paramtypes", [])
], XunkCalendarComponent);

let XunkCalendarModule = class XunkCalendarModule {
    /* Gets today's date */
    static getToday() {
        return XunkCalendarComponent.getToday();
    }
    /** Pad number with zeros */
    static zeroPad(num, padlen, padchar = '0') {
        return XunkCalendarComponent.zeropad(num, padlen, padchar);
    }
};
XunkCalendarModule = __decorate([
    NgModule({
        declarations: [
            XunkCalendarComponent
        ],
        imports: [
            CommonModule,
            MatIconModule,
            MatButtonModule,
        ],
        exports: [
            XunkCalendarComponent,
        ]
    })
], XunkCalendarModule);

export { XunkCalendarModule, XunkCalendarComponent as ɵa };
//# sourceMappingURL=xunk-calendar.js.map
