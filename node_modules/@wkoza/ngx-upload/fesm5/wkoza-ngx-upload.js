import { __values, __decorate, __metadata, __param, __spread } from 'tslib';
import { Subject } from 'rxjs';
import { HttpRequest, HttpEventType, HttpResponse, HttpErrorResponse, HttpClient, HttpClientModule } from '@angular/common/http';
import { ɵɵdefineInjectable, ɵɵinject, Injectable, InjectionToken, Input, Directive, Inject, Optional, PLATFORM_ID, ElementRef, Renderer2, Injector, ViewChild, Component, ComponentFactoryResolver, ViewContainerRef, TemplateRef, isDevMode, SkipSelf, NgModule } from '@angular/core';
import { NgForm, FormGroupDirective } from '@angular/forms';
import { isPlatformBrowser } from '@angular/common';

var FileItem = /** @class */ (function () {
    function FileItem(file, uploadService, logger, disableMultipart) {
        this.file = file;
        this.uploadService = uploadService;
        this.logger = logger;
        this.disableMultipart = disableMultipart;
        this.isReady = true;
        this.progress = 0;
        this.formData = new FormData();
        this.alias = 'file';
    }
    FileItem.prototype.upload = function (endpoint, options) {
        if (endpoint) {
            this.uploadService.uploadFileItem(this, endpoint, options);
        }
        else {
            this.logger.error('You must define a UploadEndPoint object.');
        }
    };
    FileItem.prototype.cancel = function () {
        this.logger.debug('upload cancel');
        if (this.uploadInProgress) {
            this.ɵonCancel();
            this.uploadService.cancelFileItem(this);
        }
    };
    FileItem.prototype.remove = function () {
        this.logger.debug('upload remove');
        this.uploadService.removeFromQueue(this);
    };
    FileItem.prototype.ɵonBeforeUploadItem = function () {
        this.isReady = true;
        this.uploadInProgress = false;
        this.isSuccess = false;
        this.isCancel = false;
        this.isError = false;
        this.progress = 0;
    };
    FileItem.prototype.ɵonProgress = function (progress) {
        this.isReady = false;
        this.progress = progress;
    };
    FileItem.prototype.ɵonSuccess = function () {
        this.isReady = false;
        this.uploadInProgress = false;
        this.isSuccess = true;
        this.isCancel = false;
        this.isError = false;
        this.progress = 100;
    };
    FileItem.prototype.ɵonError = function () {
        this.isReady = false;
        this.uploadInProgress = false;
        this.isSuccess = false;
        this.isCancel = false;
        this.isError = true;
        this.progress = 0;
    };
    FileItem.prototype.ɵonCancel = function () {
        this.isReady = true;
        this.uploadInProgress = false;
        this.isSuccess = false;
        this.isCancel = true;
        this.isError = false;
        this.progress = 0;
        this.sub.unsubscribe();
    };
    return FileItem;
}());

/**
 * Simple service for logging the module.
 */
var NgxUploadLogger = /** @class */ (function () {
    function NgxUploadLogger() {
    }
    return NgxUploadLogger;
}());
var noop = function () { return undefined; };
/**
 * Default implementation of Logger that safely writes the message into the console.
 *
 */
var ConsoleLogger = /** @class */ (function () {
    function ConsoleLogger(_console, _debugEnabled) {
        if (_debugEnabled === void 0) { _debugEnabled = true; }
        this._console = _console;
        this._debugEnabled = _debugEnabled;
    }
    ConsoleLogger.prototype.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._invokeConsoleMethod('log', args);
    };
    ConsoleLogger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._invokeConsoleMethod('info', args);
    };
    ConsoleLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._invokeConsoleMethod('warn', args);
    };
    ConsoleLogger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._invokeConsoleMethod('error', args);
    };
    ConsoleLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this._debugEnabled) {
            this._invokeConsoleMethod('debug', args);
        }
    };
    ConsoleLogger.prototype._invokeConsoleMethod = function (type, args) {
        var logFn = this._console[type] || this._console.log || noop;
        // console methods in IE9 don't have 'apply' method, polyfill it
        if (!logFn.apply) {
            logFn = Function.prototype.bind.call(logFn, this._console);
        }
        logFn.apply(this._console, args);
    };
    return ConsoleLogger;
}());
/**
 * No op implementation of Logger.
 *
 */
var NoOpLogger = /** @class */ (function () {
    function NoOpLogger() {
    }
    NoOpLogger.prototype.log = function () { };
    NoOpLogger.prototype.info = function () { };
    NoOpLogger.prototype.warn = function () { };
    NoOpLogger.prototype.error = function () { };
    NoOpLogger.prototype.debug = function () { };
    return NoOpLogger;
}());

// send an event for each upload event. These events can be catched by the user for call a callback
var HttpClientUploadService = /** @class */ (function () {
    function HttpClientUploadService(logger, httpClient) {
        this.logger = logger;
        this.httpClient = httpClient;
        this.progressTotal = 0;
        this.onCancel$ = new Subject();
        this.onError$ = new Subject();
        this.onDropError$ = new Subject();
        this.onSuccess$ = new Subject(); // TODO headers isn't `any` but `Array`
        this.onBeforeUploadItem$ = new Subject();
        this.onProgress$ = new Subject();
        this.onAddToQueue$ = new Subject();
        this.queue = new Array();
        this.headers = new Map();
    }
    /**
     * Adds files to the queue
     */
    HttpClientUploadService.prototype.addToQueue = function (files, formGroup, options) {
        this.logger.info('add to queue');
        if (options && !options.multiple) {
            if (files.length > 1) {
                this.logger.error('there is more than one file.');
                this.onDropError$.next({ errorAccept: false, errorMultiple: true });
                return;
            }
        }
        var _loop_1 = function (i) {
            var file = files.item(i);
            this_1.logger.debug(files.item(i));
            if (options && options.accept) {
                var accepted = options.accept.some(function (type) {
                    if (type.indexOf('/*') > -1) {
                        return type.split('/')[0] === file.type.split('/')[0];
                    }
                    else {
                        return (type === '*' || type === file.type);
                    }
                });
                if (!accepted) {
                    this_1.logger.error('this file is not accepted because of its type', file);
                    this_1.onDropError$.next({ item: file, errorAccept: true, errorMultiple: false });
                    return "continue";
                }
            }
            var fileItem;
            if (options && options.disableMultipart) {
                fileItem = new FileItem(file, this_1, this_1.logger, true);
            }
            else {
                fileItem = new FileItem(file, this_1, this_1.logger, false);
                if (formGroup) {
                    Object.keys(formGroup.controls).forEach(function (key) {
                        fileItem.formData.append(key, formGroup.get(key).value);
                    });
                }
            }
            this_1.queue.push(fileItem);
            this_1.onAddToQueue$.next(fileItem);
        };
        var this_1 = this;
        for (var i = 0; i < files.length; i++) {
            _loop_1(i);
        }
    };
    HttpClientUploadService.prototype.uploadFileItem = function (fileItem, endpoint, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.logger.info('enter uploadService.uploadFileItem()');
        var method = endpoint.method;
        var url = endpoint.url;
        var index = this.queue.indexOf(fileItem);
        var item = this.queue[index];
        this.onBeforeUploadItem(item);
        if (item.isCancel) {
            return;
        }
        item.uploadInProgress = true;
        var sendable;
        if (!fileItem.disableMultipart) {
            sendable = item.formData;
            sendable.append(item.alias, item.file, item.file.name);
        }
        else {
            sendable = item.file;
        }
        var req = new HttpRequest(method, url, sendable, Object.assign(options, { reportProgress: true }));
        fileItem.sub = this.httpClient.request(req).subscribe(function (event) {
            if (event.type === HttpEventType.UploadProgress) {
                // This is an upload progress event. Compute and show the % done:
                var percentDone = Math.round(event.loaded * 100 / (event.total ? event.total : event.loaded));
                _this.logger.debug("File is " + percentDone + "% uploaded.");
                fileItem.ɵonProgress(percentDone);
                _this.onProgressItem(item, percentDone);
            }
            else if (event instanceof HttpResponse) {
                // A successful response is delivered on the event stream.
                fileItem.ɵonSuccess();
                _this.onSuccess(item, event.body, event.status, event.headers);
            }
        }, function (err) {
            if (err instanceof HttpErrorResponse) {
                if (url === 'ngx_upload_mock') {
                    item.ɵonSuccess();
                    _this.onSuccess(item, err.message, err.status, err.headers);
                }
                else if (err.error instanceof Error) {
                    // A client-side or network error occurred. Handle it accordingly.
                    item.ɵonError();
                    _this.onError(item, err.error.message, err.status, err.headers);
                }
                else {
                    // The backend returned an unsuccessful response code.
                    // The response body may contain clues as to what went wrong,
                    item.ɵonError();
                    _this.onError(item, err.error, err.status, err.headers);
                }
            }
        });
    };
    HttpClientUploadService.prototype.cancelFileItem = function (fileItem) {
        this.progressTotal = this.computeTotalProgress();
        this.onCancel$.next(fileItem);
    };
    /**
     * Uploads all not uploaded items of queue
     */
    HttpClientUploadService.prototype.uploadAll = function (endpoint, options) {
        var e_1, _a;
        var items = this.queue.filter(function (item) { return (item.isReady); });
        if (!items.length) {
            return;
        }
        try {
            for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                var item = items_1_1.value;
                item.upload(endpoint, options);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Uploads all not uploaded items of queue
     */
    HttpClientUploadService.prototype.cancelAll = function () {
        var e_2, _a;
        var items = this.queue.filter(function (item) { return (item.uploadInProgress); });
        if (!items.length) {
            return;
        }
        try {
            for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
                var item = items_2_1.value;
                item.cancel();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (items_2_1 && !items_2_1.done && (_a = items_2.return)) _a.call(items_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.progressTotal = this.computeTotalProgress();
    };
    /**
     * Uploads all not uploaded items of queue
     */
    HttpClientUploadService.prototype.removeAllFromQueue = function () {
        var e_3, _a;
        var items = this.queue.filter(function (item) { return (!item.uploadInProgress && !item.isSuccess); });
        if (!items.length) {
            return;
        }
        try {
            for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
                var item = items_3_1.value;
                this.removeFromQueue(item);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (items_3_1 && !items_3_1.done && (_a = items_3.return)) _a.call(items_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    HttpClientUploadService.prototype.removeFromQueue = function (fileItem) {
        var index = this.queue.indexOf(fileItem);
        var item = this.queue[index];
        if (item.uploadInProgress) {
            item.cancel();
        }
        this.queue.splice(index, 1);
        this.progressTotal = this.computeTotalProgress();
    };
    /**
     * Returns the total progress
     * @param {Number} [value]
     * @returns {Number}
     * @private
     */
    HttpClientUploadService.prototype.computeTotalProgress = function () {
        var e_4, _a;
        var totalCurrent = 0;
        var total = 0;
        try {
            for (var _b = __values(this.queue), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                if (item.uploadInProgress || item.isSuccess) {
                    totalCurrent += (item.file.size / 100) * item.progress || 0;
                    total += item.file.size;
                    this.logger.debug(totalCurrent + ' / ' + total);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return Math.round((totalCurrent * 100) / total);
    };
    /**
     * Prepares file status before upload
     * @param item
     */
    HttpClientUploadService.prototype.onBeforeUploadItem = function (item) {
        this.logger.info('enter uploadService.ɵonBeforeUploadItem()');
        item.ɵonBeforeUploadItem();
        this.onBeforeUploadItem$.next(item);
    };
    /**
     * Update status during upload progress
     * @param item
     * @param progress
     */
    HttpClientUploadService.prototype.onProgressItem = function (item, progress) {
        this.logger.info("call onProgressItem " + item + " " + progress);
        this.progressTotal = this.computeTotalProgress();
        item.ɵonProgress(progress);
        this.onProgress$.next({ item: item, progress: progress });
    };
    /**
     * Callback called when an upload error occurs
     * @param item
     * @param xhr
     */
    HttpClientUploadService.prototype.onError = function (item, body, status, headers) {
        this.logger.info("call onError " + item + " " + body + " " + status + " " + headers);
        item.ɵonError();
        this.onError$.next({ item: item, body: body, status: status, headers: headers });
    };
    /**
     * Callback called when an upload success occurs
     * @param item
     * @param xhr
     */
    HttpClientUploadService.prototype.onSuccess = function (item, body, status, headers) {
        this.logger.info("call onSuccess " + item + " " + body + " " + status + " " + headers);
        this.progressTotal = this.computeTotalProgress();
        item.ɵonSuccess();
        this.onSuccess$.next({ item: item, body: body, status: status, headers: headers });
    };
    HttpClientUploadService.ngInjectableDef = ɵɵdefineInjectable({ factory: function HttpClientUploadService_Factory() { return new HttpClientUploadService(ɵɵinject(NgxUploadLogger), ɵɵinject(HttpClient)); }, token: HttpClientUploadService, providedIn: "root" });
    HttpClientUploadService = __decorate([
        Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [NgxUploadLogger, HttpClient])
    ], HttpClientUploadService);
    return HttpClientUploadService;
}());

var NGX_DROP_TARGET_OPTIONS = new InjectionToken('Ngx drop Zone Options');
var NGX_LOGGER_OPTIONS = new InjectionToken('Ngx Logger Options');
var ngxDropTargetOptions = {
    color: '',
    colorDrag: '',
    colorDrop: '',
    multiple: true,
    disableMultipart: false
};
var ngxloggerOptions = {
    enabled: false,
    debug: true
};
var ngxInputFileOptions = {
    multiple: true,
    disableMultipart: false
};

/**
 * Transforms a node into a drag and drop zone.
 */
var NgxDragAndDropDirective = /** @class */ (function () {
    function NgxDragAndDropDirective(el, renderer, injector, logger, uploader, dropOptions, ngForm, formGroupDirective, platformId) {
        var _this = this;
        this.el = el;
        this.renderer = renderer;
        this.injector = injector;
        this.logger = logger;
        this.uploader = uploader;
        this.dropOptions = dropOptions;
        this.ngForm = ngForm;
        this.formGroupDirective = formGroupDirective;
        if (this.ngForm) {
            this.formGroup = ngForm.form;
        }
        else if (this.formGroupDirective) {
            this.formGroup = formGroupDirective.form;
        }
        else {
            this.formGroup = null;
        }
        if (isPlatformBrowser(platformId)) {
            this.renderer.listen(el.nativeElement, 'dragleave', function ($event) { return _this.onDragLeave($event); });
            this.renderer.listen(el.nativeElement, 'drop', function ($event) { return _this.dropEvent($event); });
            this.renderer.listen(el.nativeElement, 'dragover', function ($event) { return _this.onDragOver($event); });
        }
    }
    Object.defineProperty(NgxDragAndDropDirective.prototype, "ngxDragAndDrop", {
        set: function (dropOptions) {
            if (dropOptions) {
                this.logger.debug(JSON.stringify(dropOptions));
                this.dropOptions = dropOptions;
            }
        },
        enumerable: true,
        configurable: true
    });
    NgxDragAndDropDirective.prototype.ngOnInit = function () {
        this.renderer.addClass(this.el.nativeElement, this.dropOptions.color);
    };
    NgxDragAndDropDirective.prototype.onDragLeave = function (event) {
        this.logger.debug('dragleave event');
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrag);
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrop);
        this.renderer.addClass(this.el.nativeElement, this.dropOptions.color);
        this.stopAndPrevent(event);
    };
    NgxDragAndDropDirective.prototype.dropEvent = function (event) {
        this.logger.debug('drop event');
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.color);
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrag);
        this.renderer.addClass(this.el.nativeElement, this.dropOptions.colorDrop);
        var transfer = this.getTransfer(event);
        if (!transfer) {
            return;
        }
        transfer.dropEffect = 'copy';
        this.stopAndPrevent(event);
        this.uploader.addToQueue(transfer.files, this.formGroup, this.dropOptions);
    };
    NgxDragAndDropDirective.prototype.onDragOver = function (event) {
        this.logger.debug('dragover event');
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.color);
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrop);
        this.renderer.addClass(this.el.nativeElement, this.dropOptions.colorDrag);
        var transfer = this.getTransfer(event);
        if (!this.haveFiles(transfer.types)) {
            return;
        }
        this.stopAndPrevent(event);
    };
    NgxDragAndDropDirective.prototype.stopAndPrevent = function (event) {
        event.stopPropagation();
        event.preventDefault();
    };
    NgxDragAndDropDirective.prototype.getTransfer = function (event) {
        return event.dataTransfer ? event.dataTransfer : event.originalEvent.dataTransfer;
    };
    NgxDragAndDropDirective.prototype.haveFiles = function (types) {
        if (!types) {
            return false;
        }
        if (types.indexOf) {
            return types.indexOf('Files') !== -1;
        }
        else if (types.contains) {
            return types.contains('Files');
        }
        else {
            return false;
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], NgxDragAndDropDirective.prototype, "ngxDragAndDrop", null);
    NgxDragAndDropDirective = __decorate([
        Directive({
            selector: '[ngxDragAndDrop]',
            exportAs: 'ngxDragAndDrop'
        }),
        __param(5, Inject(NGX_DROP_TARGET_OPTIONS)),
        __param(6, Optional()), __param(7, Optional()),
        __param(8, Inject(PLATFORM_ID)),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            Injector,
            NgxUploadLogger,
            HttpClientUploadService, Object, NgForm, FormGroupDirective,
            Object])
    ], NgxDragAndDropDirective);
    return NgxDragAndDropDirective;
}());

/**
 * Transforms a node into a thumbnail zone.
 */
var NgxThumbnailDirective = /** @class */ (function () {
    function NgxThumbnailDirective(renderer, el) {
        this.renderer = renderer;
        this.el = el;
    }
    NgxThumbnailDirective.prototype.ngOnInit = function () {
        var _this = this;
        // must be used only with image file
        if (this.fileItem.file.type.indexOf('image/jpeg') !== 0 &&
            this.fileItem.file.type.indexOf('image/png') !== 0) {
            return;
        }
        else {
            var imgEl_1 = this.renderer.createElement('img');
            this.renderer.appendChild(this.el.nativeElement, imgEl_1);
            this.renderer.setStyle(imgEl_1, 'width', '100%');
            this.renderer.setStyle(imgEl_1, 'height', '100%');
            this._getOrientation(this.fileItem.file, function (srcOrientation) {
                var img = new Image();
                var reader = new FileReader();
                reader.onload = function (evt) {
                    img.onload = function () {
                        var width = img.width, height = img.height, canvas = document.createElement('canvas'), ctx = canvas.getContext('2d');
                        // set proper canvas dimensions before transform & export
                        if (4 < srcOrientation && srcOrientation < 9) {
                            canvas.width = height;
                            canvas.height = width;
                        }
                        else {
                            canvas.width = width;
                            canvas.height = height;
                        }
                        // transform context before drawing image
                        switch (srcOrientation) {
                            case 2:
                                ctx.transform(-1, 0, 0, 1, width, 0);
                                break;
                            case 3:
                                ctx.transform(-1, 0, 0, -1, width, height);
                                break;
                            case 4:
                                ctx.transform(1, 0, 0, -1, 0, height);
                                break;
                            case 5:
                                ctx.transform(0, 1, 1, 0, 0, 0);
                                break;
                            case 6:
                                ctx.transform(0, 1, -1, 0, height, 0);
                                break;
                            case 7:
                                ctx.transform(0, -1, -1, 0, height, width);
                                break;
                            case 8:
                                ctx.transform(0, -1, 1, 0, 0, width);
                                break;
                            default:
                                break;
                        }
                        // draw image
                        ctx.drawImage(img, 0, 0);
                        _this.renderer.setProperty(imgEl_1, 'src', canvas.toDataURL());
                    };
                    img.src = evt.target['result'];
                };
                reader.readAsDataURL(_this.fileItem.file);
            });
        }
    };
    /*
    * getOrientation computes the real orientation of the image
    *
    */
    NgxThumbnailDirective.prototype._getOrientation = function (file, callback) {
        var reader = new FileReader();
        reader.onload = function (event) {
            var view = new DataView(event.target['result']);
            if (view.getUint16(0, false) !== 0xFFD8)
                return callback(-2);
            var length = view.byteLength;
            var offset = 2;
            while (offset < length) {
                var marker = view.getUint16(offset, false);
                offset += 2;
                if (marker === 0xFFE1) {
                    if (view.getUint32(offset += 2, false) !== 0x45786966) {
                        return callback(-1);
                    }
                    var little = view.getUint16(offset += 6, false) === 0x4949;
                    offset += view.getUint32(offset + 4, little);
                    var tags = view.getUint16(offset, little);
                    offset += 2;
                    for (var i = 0; i < tags; i++)
                        if (view.getUint16(offset + (i * 12), little) === 0x0112)
                            return callback(view.getUint16(offset + (i * 12) + 8, little));
                }
                else if ((marker & 0xFF00) !== 0xFF00)
                    break;
                else
                    offset += view.getUint16(offset, false);
            }
            return callback(-1);
        };
        reader.readAsArrayBuffer(file.slice(0, 64 * 1024));
    };
    __decorate([
        Input('ngxThumbnail'),
        __metadata("design:type", FileItem)
    ], NgxThumbnailDirective.prototype, "fileItem", void 0);
    NgxThumbnailDirective = __decorate([
        Directive({
            selector: '[ngxThumbnail]',
            exportAs: 'ngxThumbnail'
        }),
        __metadata("design:paramtypes", [Renderer2, ElementRef])
    ], NgxThumbnailDirective);
    return NgxThumbnailDirective;
}());

var InputfileComponent = /** @class */ (function () {
    function InputfileComponent(injector, uploader, renderer, ngForm, formGroupDirective) {
        this.injector = injector;
        this.uploader = uploader;
        this.renderer = renderer;
        this.ngForm = ngForm;
        this.formGroupDirective = formGroupDirective;
        this.files = new Set();
        if (this.ngForm) {
            this.formGroup = ngForm.form;
        }
        else if (this.formGroupDirective) {
            this.formGroup = formGroupDirective.form;
        }
        else {
            this.formGroup = null;
        }
    }
    InputfileComponent.prototype.onFilesAdded = function () {
        this.uploader.addToQueue(this.file.nativeElement.files, this.formGroup, this.options);
        // Clear the previous input value
        this.file.nativeElement.value = '';
    };
    InputfileComponent.prototype.ngAfterViewInit = function () {
        if (this.options.multiple !== false)
            this.renderer.setProperty(this.file.nativeElement, 'multiple', 'multiple');
        if (this.options.accept)
            this.renderer.setProperty(this.file.nativeElement, 'accept', this.options.accept.join());
        if (this.options.capture)
            this.renderer.setProperty(this.file.nativeElement, 'capture', this.options.capture);
    };
    __decorate([
        ViewChild('file', { static: true }),
        __metadata("design:type", Object)
    ], InputfileComponent.prototype, "file", void 0);
    InputfileComponent = __decorate([
        Component({
            selector: 'ngx-upload-inputfile',
            template: "\n      <label class=\"input-file\">\n          <input type=\"file\" #file (change)=\"onFilesAdded()\">\n          <ng-content></ng-content>\n      </label>",
            styles: ['input[type="file"] { display: none; } .input-file { width: 100%; }']
        }),
        __param(3, Optional()), __param(4, Optional()),
        __metadata("design:paramtypes", [Injector, HttpClientUploadService, Renderer2,
            NgForm, FormGroupDirective])
    ], InputfileComponent);
    return InputfileComponent;
}());

var NgxInputFileDirective = /** @class */ (function () {
    function NgxInputFileDirective(resolver, injector, vcRef, templateRef) {
        this.resolver = resolver;
        this.injector = injector;
        this.vcRef = vcRef;
        this.templateRef = templateRef;
    }
    NgxInputFileDirective.prototype.ngOnInit = function () {
        var _contentViewRef = this.templateRef.createEmbeddedView(null);
        var factory = this.resolver.resolveComponentFactory(InputfileComponent);
        var component = this.vcRef.createComponent(factory, 0, this.injector, [_contentViewRef.rootNodes]);
        component.instance.options = (this.ngxInputFile) ? this.ngxInputFile : ngxInputFileOptions;
        _contentViewRef.detectChanges();
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NgxInputFileDirective.prototype, "ngxInputFile", void 0);
    NgxInputFileDirective = __decorate([
        Directive({
            selector: '[ngxInputFile]'
        }),
        __metadata("design:paramtypes", [ComponentFactoryResolver, Injector,
            ViewContainerRef, TemplateRef])
    ], NgxInputFileDirective);
    return NgxInputFileDirective;
}());

var ngxDeclarations = [
    NgxDragAndDropDirective, NgxThumbnailDirective, InputfileComponent, NgxInputFileDirective
];
/**
 * Factory associated with internal logger
 * @param options
 * @returns {any}
 * @private
 */
function _loggerFactory(options) {
    var enabled = options.enabled ? options.enabled : isDevMode();
    if (enabled) {
        var _console = typeof console === 'object' ? console : {};
        var debug = options.debug ? options.debug : true;
        return new ConsoleLogger(_console, debug);
    }
    return new NoOpLogger();
}
var NGX_UPLOAD_ROOT_GUARD = new InjectionToken('Internal forRoot Guard');
function createNgxUploadRootGuard(options) {
    if (options) {
        throw new TypeError('NgxUploadModule.forRoot() is called twice.');
    }
    return 'guarded';
}
var NgxUploadModule = /** @class */ (function () {
    function NgxUploadModule() {
    }
    NgxUploadModule_1 = NgxUploadModule;
    NgxUploadModule.forRoot = function (dropTargetOptions, loggerOptions) {
        return {
            ngModule: NgxUploadModule_1,
            providers: [
                { provide: NGX_LOGGER_OPTIONS, useValue: (loggerOptions) ? loggerOptions : ngxloggerOptions },
                {
                    provide: NGX_DROP_TARGET_OPTIONS,
                    useValue: (dropTargetOptions) ? dropTargetOptions : ngxDropTargetOptions
                },
                {
                    provide: NgxUploadLogger,
                    useFactory: _loggerFactory,
                    deps: [NGX_LOGGER_OPTIONS]
                },
                {
                    provide: NGX_UPLOAD_ROOT_GUARD,
                    useFactory: createNgxUploadRootGuard,
                    deps: [[NGX_LOGGER_OPTIONS, new Optional(), new SkipSelf()]]
                }
            ]
        };
    };
    var NgxUploadModule_1;
    NgxUploadModule = NgxUploadModule_1 = __decorate([
        NgModule({
            declarations: __spread(ngxDeclarations),
            exports: __spread(ngxDeclarations),
            imports: [HttpClientModule],
            entryComponents: [InputfileComponent]
        })
    ], NgxUploadModule);
    return NgxUploadModule;
}());

export { FileItem, HttpClientUploadService, NgxUploadModule, NGX_DROP_TARGET_OPTIONS as ɵa, NGX_LOGGER_OPTIONS as ɵb, ngxDropTargetOptions as ɵc, ngxloggerOptions as ɵd, _loggerFactory as ɵe, NGX_UPLOAD_ROOT_GUARD as ɵf, createNgxUploadRootGuard as ɵg, NgxUploadLogger as ɵh, NgxDragAndDropDirective as ɵi, NgxThumbnailDirective as ɵj, InputfileComponent as ɵk, NgxInputFileDirective as ɵl };
//# sourceMappingURL=wkoza-ngx-upload.js.map
