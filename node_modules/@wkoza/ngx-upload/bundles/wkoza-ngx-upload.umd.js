(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('@angular/common/http'), require('@angular/core'), require('@angular/forms'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@wkoza/ngx-upload', ['exports', 'rxjs', '@angular/common/http', '@angular/core', '@angular/forms', '@angular/common'], factory) :
    (global = global || self, factory((global.wkoza = global.wkoza || {}, global.wkoza['ngx-upload'] = {}), global.rxjs, global.ng.common.http, global.ng.core, global.ng.forms, global.ng.common));
}(this, function (exports, rxjs, http, core, forms, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    var FileItem = /** @class */ (function () {
        function FileItem(file, uploadService, logger, disableMultipart) {
            this.file = file;
            this.uploadService = uploadService;
            this.logger = logger;
            this.disableMultipart = disableMultipart;
            this.isReady = true;
            this.progress = 0;
            this.formData = new FormData();
            this.alias = 'file';
        }
        FileItem.prototype.upload = function (endpoint, options) {
            if (endpoint) {
                this.uploadService.uploadFileItem(this, endpoint, options);
            }
            else {
                this.logger.error('You must define a UploadEndPoint object.');
            }
        };
        FileItem.prototype.cancel = function () {
            this.logger.debug('upload cancel');
            if (this.uploadInProgress) {
                this.ɵonCancel();
                this.uploadService.cancelFileItem(this);
            }
        };
        FileItem.prototype.remove = function () {
            this.logger.debug('upload remove');
            this.uploadService.removeFromQueue(this);
        };
        FileItem.prototype.ɵonBeforeUploadItem = function () {
            this.isReady = true;
            this.uploadInProgress = false;
            this.isSuccess = false;
            this.isCancel = false;
            this.isError = false;
            this.progress = 0;
        };
        FileItem.prototype.ɵonProgress = function (progress) {
            this.isReady = false;
            this.progress = progress;
        };
        FileItem.prototype.ɵonSuccess = function () {
            this.isReady = false;
            this.uploadInProgress = false;
            this.isSuccess = true;
            this.isCancel = false;
            this.isError = false;
            this.progress = 100;
        };
        FileItem.prototype.ɵonError = function () {
            this.isReady = false;
            this.uploadInProgress = false;
            this.isSuccess = false;
            this.isCancel = false;
            this.isError = true;
            this.progress = 0;
        };
        FileItem.prototype.ɵonCancel = function () {
            this.isReady = true;
            this.uploadInProgress = false;
            this.isSuccess = false;
            this.isCancel = true;
            this.isError = false;
            this.progress = 0;
            this.sub.unsubscribe();
        };
        return FileItem;
    }());

    /**
     * Simple service for logging the module.
     */
    var NgxUploadLogger = /** @class */ (function () {
        function NgxUploadLogger() {
        }
        return NgxUploadLogger;
    }());
    var noop = function () { return undefined; };
    /**
     * Default implementation of Logger that safely writes the message into the console.
     *
     */
    var ConsoleLogger = /** @class */ (function () {
        function ConsoleLogger(_console, _debugEnabled) {
            if (_debugEnabled === void 0) { _debugEnabled = true; }
            this._console = _console;
            this._debugEnabled = _debugEnabled;
        }
        ConsoleLogger.prototype.log = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._invokeConsoleMethod('log', args);
        };
        ConsoleLogger.prototype.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._invokeConsoleMethod('info', args);
        };
        ConsoleLogger.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._invokeConsoleMethod('warn', args);
        };
        ConsoleLogger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._invokeConsoleMethod('error', args);
        };
        ConsoleLogger.prototype.debug = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (this._debugEnabled) {
                this._invokeConsoleMethod('debug', args);
            }
        };
        ConsoleLogger.prototype._invokeConsoleMethod = function (type, args) {
            var logFn = this._console[type] || this._console.log || noop;
            // console methods in IE9 don't have 'apply' method, polyfill it
            if (!logFn.apply) {
                logFn = Function.prototype.bind.call(logFn, this._console);
            }
            logFn.apply(this._console, args);
        };
        return ConsoleLogger;
    }());
    /**
     * No op implementation of Logger.
     *
     */
    var NoOpLogger = /** @class */ (function () {
        function NoOpLogger() {
        }
        NoOpLogger.prototype.log = function () { };
        NoOpLogger.prototype.info = function () { };
        NoOpLogger.prototype.warn = function () { };
        NoOpLogger.prototype.error = function () { };
        NoOpLogger.prototype.debug = function () { };
        return NoOpLogger;
    }());

    // send an event for each upload event. These events can be catched by the user for call a callback
    var HttpClientUploadService = /** @class */ (function () {
        function HttpClientUploadService(logger, httpClient) {
            this.logger = logger;
            this.httpClient = httpClient;
            this.progressTotal = 0;
            this.onCancel$ = new rxjs.Subject();
            this.onError$ = new rxjs.Subject();
            this.onDropError$ = new rxjs.Subject();
            this.onSuccess$ = new rxjs.Subject(); // TODO headers isn't `any` but `Array`
            this.onBeforeUploadItem$ = new rxjs.Subject();
            this.onProgress$ = new rxjs.Subject();
            this.onAddToQueue$ = new rxjs.Subject();
            this.queue = new Array();
            this.headers = new Map();
        }
        /**
         * Adds files to the queue
         */
        HttpClientUploadService.prototype.addToQueue = function (files, formGroup, options) {
            this.logger.info('add to queue');
            if (options && !options.multiple) {
                if (files.length > 1) {
                    this.logger.error('there is more than one file.');
                    this.onDropError$.next({ errorAccept: false, errorMultiple: true });
                    return;
                }
            }
            var _loop_1 = function (i) {
                var file = files.item(i);
                this_1.logger.debug(files.item(i));
                if (options && options.accept) {
                    var accepted = options.accept.some(function (type) {
                        if (type.indexOf('/*') > -1) {
                            return type.split('/')[0] === file.type.split('/')[0];
                        }
                        else {
                            return (type === '*' || type === file.type);
                        }
                    });
                    if (!accepted) {
                        this_1.logger.error('this file is not accepted because of its type', file);
                        this_1.onDropError$.next({ item: file, errorAccept: true, errorMultiple: false });
                        return "continue";
                    }
                }
                var fileItem;
                if (options && options.disableMultipart) {
                    fileItem = new FileItem(file, this_1, this_1.logger, true);
                }
                else {
                    fileItem = new FileItem(file, this_1, this_1.logger, false);
                    if (formGroup) {
                        Object.keys(formGroup.controls).forEach(function (key) {
                            fileItem.formData.append(key, formGroup.get(key).value);
                        });
                    }
                }
                this_1.queue.push(fileItem);
                this_1.onAddToQueue$.next(fileItem);
            };
            var this_1 = this;
            for (var i = 0; i < files.length; i++) {
                _loop_1(i);
            }
        };
        HttpClientUploadService.prototype.uploadFileItem = function (fileItem, endpoint, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            this.logger.info('enter uploadService.uploadFileItem()');
            var method = endpoint.method;
            var url = endpoint.url;
            var index = this.queue.indexOf(fileItem);
            var item = this.queue[index];
            this.onBeforeUploadItem(item);
            if (item.isCancel) {
                return;
            }
            item.uploadInProgress = true;
            var sendable;
            if (!fileItem.disableMultipart) {
                sendable = item.formData;
                sendable.append(item.alias, item.file, item.file.name);
            }
            else {
                sendable = item.file;
            }
            var req = new http.HttpRequest(method, url, sendable, Object.assign(options, { reportProgress: true }));
            fileItem.sub = this.httpClient.request(req).subscribe(function (event) {
                if (event.type === http.HttpEventType.UploadProgress) {
                    // This is an upload progress event. Compute and show the % done:
                    var percentDone = Math.round(event.loaded * 100 / (event.total ? event.total : event.loaded));
                    _this.logger.debug("File is " + percentDone + "% uploaded.");
                    fileItem.ɵonProgress(percentDone);
                    _this.onProgressItem(item, percentDone);
                }
                else if (event instanceof http.HttpResponse) {
                    // A successful response is delivered on the event stream.
                    fileItem.ɵonSuccess();
                    _this.onSuccess(item, event.body, event.status, event.headers);
                }
            }, function (err) {
                if (err instanceof http.HttpErrorResponse) {
                    if (url === 'ngx_upload_mock') {
                        item.ɵonSuccess();
                        _this.onSuccess(item, err.message, err.status, err.headers);
                    }
                    else if (err.error instanceof Error) {
                        // A client-side or network error occurred. Handle it accordingly.
                        item.ɵonError();
                        _this.onError(item, err.error.message, err.status, err.headers);
                    }
                    else {
                        // The backend returned an unsuccessful response code.
                        // The response body may contain clues as to what went wrong,
                        item.ɵonError();
                        _this.onError(item, err.error, err.status, err.headers);
                    }
                }
            });
        };
        HttpClientUploadService.prototype.cancelFileItem = function (fileItem) {
            this.progressTotal = this.computeTotalProgress();
            this.onCancel$.next(fileItem);
        };
        /**
         * Uploads all not uploaded items of queue
         */
        HttpClientUploadService.prototype.uploadAll = function (endpoint, options) {
            var e_1, _a;
            var items = this.queue.filter(function (item) { return (item.isReady); });
            if (!items.length) {
                return;
            }
            try {
                for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                    var item = items_1_1.value;
                    item.upload(endpoint, options);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * Uploads all not uploaded items of queue
         */
        HttpClientUploadService.prototype.cancelAll = function () {
            var e_2, _a;
            var items = this.queue.filter(function (item) { return (item.uploadInProgress); });
            if (!items.length) {
                return;
            }
            try {
                for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
                    var item = items_2_1.value;
                    item.cancel();
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (items_2_1 && !items_2_1.done && (_a = items_2.return)) _a.call(items_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.progressTotal = this.computeTotalProgress();
        };
        /**
         * Uploads all not uploaded items of queue
         */
        HttpClientUploadService.prototype.removeAllFromQueue = function () {
            var e_3, _a;
            var items = this.queue.filter(function (item) { return (!item.uploadInProgress && !item.isSuccess); });
            if (!items.length) {
                return;
            }
            try {
                for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
                    var item = items_3_1.value;
                    this.removeFromQueue(item);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (items_3_1 && !items_3_1.done && (_a = items_3.return)) _a.call(items_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        HttpClientUploadService.prototype.removeFromQueue = function (fileItem) {
            var index = this.queue.indexOf(fileItem);
            var item = this.queue[index];
            if (item.uploadInProgress) {
                item.cancel();
            }
            this.queue.splice(index, 1);
            this.progressTotal = this.computeTotalProgress();
        };
        /**
         * Returns the total progress
         * @param {Number} [value]
         * @returns {Number}
         * @private
         */
        HttpClientUploadService.prototype.computeTotalProgress = function () {
            var e_4, _a;
            var totalCurrent = 0;
            var total = 0;
            try {
                for (var _b = __values(this.queue), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    if (item.uploadInProgress || item.isSuccess) {
                        totalCurrent += (item.file.size / 100) * item.progress || 0;
                        total += item.file.size;
                        this.logger.debug(totalCurrent + ' / ' + total);
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return Math.round((totalCurrent * 100) / total);
        };
        /**
         * Prepares file status before upload
         * @param item
         */
        HttpClientUploadService.prototype.onBeforeUploadItem = function (item) {
            this.logger.info('enter uploadService.ɵonBeforeUploadItem()');
            item.ɵonBeforeUploadItem();
            this.onBeforeUploadItem$.next(item);
        };
        /**
         * Update status during upload progress
         * @param item
         * @param progress
         */
        HttpClientUploadService.prototype.onProgressItem = function (item, progress) {
            this.logger.info("call onProgressItem " + item + " " + progress);
            this.progressTotal = this.computeTotalProgress();
            item.ɵonProgress(progress);
            this.onProgress$.next({ item: item, progress: progress });
        };
        /**
         * Callback called when an upload error occurs
         * @param item
         * @param xhr
         */
        HttpClientUploadService.prototype.onError = function (item, body, status, headers) {
            this.logger.info("call onError " + item + " " + body + " " + status + " " + headers);
            item.ɵonError();
            this.onError$.next({ item: item, body: body, status: status, headers: headers });
        };
        /**
         * Callback called when an upload success occurs
         * @param item
         * @param xhr
         */
        HttpClientUploadService.prototype.onSuccess = function (item, body, status, headers) {
            this.logger.info("call onSuccess " + item + " " + body + " " + status + " " + headers);
            this.progressTotal = this.computeTotalProgress();
            item.ɵonSuccess();
            this.onSuccess$.next({ item: item, body: body, status: status, headers: headers });
        };
        HttpClientUploadService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function HttpClientUploadService_Factory() { return new HttpClientUploadService(core.ɵɵinject(NgxUploadLogger), core.ɵɵinject(http.HttpClient)); }, token: HttpClientUploadService, providedIn: "root" });
        HttpClientUploadService = __decorate([
            core.Injectable({
                providedIn: 'root'
            }),
            __metadata("design:paramtypes", [NgxUploadLogger, http.HttpClient])
        ], HttpClientUploadService);
        return HttpClientUploadService;
    }());

    var NGX_DROP_TARGET_OPTIONS = new core.InjectionToken('Ngx drop Zone Options');
    var NGX_LOGGER_OPTIONS = new core.InjectionToken('Ngx Logger Options');
    var ngxDropTargetOptions = {
        color: '',
        colorDrag: '',
        colorDrop: '',
        multiple: true,
        disableMultipart: false
    };
    var ngxloggerOptions = {
        enabled: false,
        debug: true
    };
    var ngxInputFileOptions = {
        multiple: true,
        disableMultipart: false
    };

    /**
     * Transforms a node into a drag and drop zone.
     */
    var NgxDragAndDropDirective = /** @class */ (function () {
        function NgxDragAndDropDirective(el, renderer, injector, logger, uploader, dropOptions, ngForm, formGroupDirective, platformId) {
            var _this = this;
            this.el = el;
            this.renderer = renderer;
            this.injector = injector;
            this.logger = logger;
            this.uploader = uploader;
            this.dropOptions = dropOptions;
            this.ngForm = ngForm;
            this.formGroupDirective = formGroupDirective;
            if (this.ngForm) {
                this.formGroup = ngForm.form;
            }
            else if (this.formGroupDirective) {
                this.formGroup = formGroupDirective.form;
            }
            else {
                this.formGroup = null;
            }
            if (common.isPlatformBrowser(platformId)) {
                this.renderer.listen(el.nativeElement, 'dragleave', function ($event) { return _this.onDragLeave($event); });
                this.renderer.listen(el.nativeElement, 'drop', function ($event) { return _this.dropEvent($event); });
                this.renderer.listen(el.nativeElement, 'dragover', function ($event) { return _this.onDragOver($event); });
            }
        }
        Object.defineProperty(NgxDragAndDropDirective.prototype, "ngxDragAndDrop", {
            set: function (dropOptions) {
                if (dropOptions) {
                    this.logger.debug(JSON.stringify(dropOptions));
                    this.dropOptions = dropOptions;
                }
            },
            enumerable: true,
            configurable: true
        });
        NgxDragAndDropDirective.prototype.ngOnInit = function () {
            this.renderer.addClass(this.el.nativeElement, this.dropOptions.color);
        };
        NgxDragAndDropDirective.prototype.onDragLeave = function (event) {
            this.logger.debug('dragleave event');
            this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrag);
            this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrop);
            this.renderer.addClass(this.el.nativeElement, this.dropOptions.color);
            this.stopAndPrevent(event);
        };
        NgxDragAndDropDirective.prototype.dropEvent = function (event) {
            this.logger.debug('drop event');
            this.renderer.removeClass(this.el.nativeElement, this.dropOptions.color);
            this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrag);
            this.renderer.addClass(this.el.nativeElement, this.dropOptions.colorDrop);
            var transfer = this.getTransfer(event);
            if (!transfer) {
                return;
            }
            transfer.dropEffect = 'copy';
            this.stopAndPrevent(event);
            this.uploader.addToQueue(transfer.files, this.formGroup, this.dropOptions);
        };
        NgxDragAndDropDirective.prototype.onDragOver = function (event) {
            this.logger.debug('dragover event');
            this.renderer.removeClass(this.el.nativeElement, this.dropOptions.color);
            this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrop);
            this.renderer.addClass(this.el.nativeElement, this.dropOptions.colorDrag);
            var transfer = this.getTransfer(event);
            if (!this.haveFiles(transfer.types)) {
                return;
            }
            this.stopAndPrevent(event);
        };
        NgxDragAndDropDirective.prototype.stopAndPrevent = function (event) {
            event.stopPropagation();
            event.preventDefault();
        };
        NgxDragAndDropDirective.prototype.getTransfer = function (event) {
            return event.dataTransfer ? event.dataTransfer : event.originalEvent.dataTransfer;
        };
        NgxDragAndDropDirective.prototype.haveFiles = function (types) {
            if (!types) {
                return false;
            }
            if (types.indexOf) {
                return types.indexOf('Files') !== -1;
            }
            else if (types.contains) {
                return types.contains('Files');
            }
            else {
                return false;
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxDragAndDropDirective.prototype, "ngxDragAndDrop", null);
        NgxDragAndDropDirective = __decorate([
            core.Directive({
                selector: '[ngxDragAndDrop]',
                exportAs: 'ngxDragAndDrop'
            }),
            __param(5, core.Inject(NGX_DROP_TARGET_OPTIONS)),
            __param(6, core.Optional()), __param(7, core.Optional()),
            __param(8, core.Inject(core.PLATFORM_ID)),
            __metadata("design:paramtypes", [core.ElementRef,
                core.Renderer2,
                core.Injector,
                NgxUploadLogger,
                HttpClientUploadService, Object, forms.NgForm, forms.FormGroupDirective,
                Object])
        ], NgxDragAndDropDirective);
        return NgxDragAndDropDirective;
    }());

    /**
     * Transforms a node into a thumbnail zone.
     */
    var NgxThumbnailDirective = /** @class */ (function () {
        function NgxThumbnailDirective(renderer, el) {
            this.renderer = renderer;
            this.el = el;
        }
        NgxThumbnailDirective.prototype.ngOnInit = function () {
            var _this = this;
            // must be used only with image file
            if (this.fileItem.file.type.indexOf('image/jpeg') !== 0 &&
                this.fileItem.file.type.indexOf('image/png') !== 0) {
                return;
            }
            else {
                var imgEl_1 = this.renderer.createElement('img');
                this.renderer.appendChild(this.el.nativeElement, imgEl_1);
                this.renderer.setStyle(imgEl_1, 'width', '100%');
                this.renderer.setStyle(imgEl_1, 'height', '100%');
                this._getOrientation(this.fileItem.file, function (srcOrientation) {
                    var img = new Image();
                    var reader = new FileReader();
                    reader.onload = function (evt) {
                        img.onload = function () {
                            var width = img.width, height = img.height, canvas = document.createElement('canvas'), ctx = canvas.getContext('2d');
                            // set proper canvas dimensions before transform & export
                            if (4 < srcOrientation && srcOrientation < 9) {
                                canvas.width = height;
                                canvas.height = width;
                            }
                            else {
                                canvas.width = width;
                                canvas.height = height;
                            }
                            // transform context before drawing image
                            switch (srcOrientation) {
                                case 2:
                                    ctx.transform(-1, 0, 0, 1, width, 0);
                                    break;
                                case 3:
                                    ctx.transform(-1, 0, 0, -1, width, height);
                                    break;
                                case 4:
                                    ctx.transform(1, 0, 0, -1, 0, height);
                                    break;
                                case 5:
                                    ctx.transform(0, 1, 1, 0, 0, 0);
                                    break;
                                case 6:
                                    ctx.transform(0, 1, -1, 0, height, 0);
                                    break;
                                case 7:
                                    ctx.transform(0, -1, -1, 0, height, width);
                                    break;
                                case 8:
                                    ctx.transform(0, -1, 1, 0, 0, width);
                                    break;
                                default:
                                    break;
                            }
                            // draw image
                            ctx.drawImage(img, 0, 0);
                            _this.renderer.setProperty(imgEl_1, 'src', canvas.toDataURL());
                        };
                        img.src = evt.target['result'];
                    };
                    reader.readAsDataURL(_this.fileItem.file);
                });
            }
        };
        /*
        * getOrientation computes the real orientation of the image
        *
        */
        NgxThumbnailDirective.prototype._getOrientation = function (file, callback) {
            var reader = new FileReader();
            reader.onload = function (event) {
                var view = new DataView(event.target['result']);
                if (view.getUint16(0, false) !== 0xFFD8)
                    return callback(-2);
                var length = view.byteLength;
                var offset = 2;
                while (offset < length) {
                    var marker = view.getUint16(offset, false);
                    offset += 2;
                    if (marker === 0xFFE1) {
                        if (view.getUint32(offset += 2, false) !== 0x45786966) {
                            return callback(-1);
                        }
                        var little = view.getUint16(offset += 6, false) === 0x4949;
                        offset += view.getUint32(offset + 4, little);
                        var tags = view.getUint16(offset, little);
                        offset += 2;
                        for (var i = 0; i < tags; i++)
                            if (view.getUint16(offset + (i * 12), little) === 0x0112)
                                return callback(view.getUint16(offset + (i * 12) + 8, little));
                    }
                    else if ((marker & 0xFF00) !== 0xFF00)
                        break;
                    else
                        offset += view.getUint16(offset, false);
                }
                return callback(-1);
            };
            reader.readAsArrayBuffer(file.slice(0, 64 * 1024));
        };
        __decorate([
            core.Input('ngxThumbnail'),
            __metadata("design:type", FileItem)
        ], NgxThumbnailDirective.prototype, "fileItem", void 0);
        NgxThumbnailDirective = __decorate([
            core.Directive({
                selector: '[ngxThumbnail]',
                exportAs: 'ngxThumbnail'
            }),
            __metadata("design:paramtypes", [core.Renderer2, core.ElementRef])
        ], NgxThumbnailDirective);
        return NgxThumbnailDirective;
    }());

    var InputfileComponent = /** @class */ (function () {
        function InputfileComponent(injector, uploader, renderer, ngForm, formGroupDirective) {
            this.injector = injector;
            this.uploader = uploader;
            this.renderer = renderer;
            this.ngForm = ngForm;
            this.formGroupDirective = formGroupDirective;
            this.files = new Set();
            if (this.ngForm) {
                this.formGroup = ngForm.form;
            }
            else if (this.formGroupDirective) {
                this.formGroup = formGroupDirective.form;
            }
            else {
                this.formGroup = null;
            }
        }
        InputfileComponent.prototype.onFilesAdded = function () {
            this.uploader.addToQueue(this.file.nativeElement.files, this.formGroup, this.options);
            // Clear the previous input value
            this.file.nativeElement.value = '';
        };
        InputfileComponent.prototype.ngAfterViewInit = function () {
            if (this.options.multiple !== false)
                this.renderer.setProperty(this.file.nativeElement, 'multiple', 'multiple');
            if (this.options.accept)
                this.renderer.setProperty(this.file.nativeElement, 'accept', this.options.accept.join());
            if (this.options.capture)
                this.renderer.setProperty(this.file.nativeElement, 'capture', this.options.capture);
        };
        __decorate([
            core.ViewChild('file', { static: true }),
            __metadata("design:type", Object)
        ], InputfileComponent.prototype, "file", void 0);
        InputfileComponent = __decorate([
            core.Component({
                selector: 'ngx-upload-inputfile',
                template: "\n      <label class=\"input-file\">\n          <input type=\"file\" #file (change)=\"onFilesAdded()\">\n          <ng-content></ng-content>\n      </label>",
                styles: ['input[type="file"] { display: none; } .input-file { width: 100%; }']
            }),
            __param(3, core.Optional()), __param(4, core.Optional()),
            __metadata("design:paramtypes", [core.Injector, HttpClientUploadService, core.Renderer2,
                forms.NgForm, forms.FormGroupDirective])
        ], InputfileComponent);
        return InputfileComponent;
    }());

    var NgxInputFileDirective = /** @class */ (function () {
        function NgxInputFileDirective(resolver, injector, vcRef, templateRef) {
            this.resolver = resolver;
            this.injector = injector;
            this.vcRef = vcRef;
            this.templateRef = templateRef;
        }
        NgxInputFileDirective.prototype.ngOnInit = function () {
            var _contentViewRef = this.templateRef.createEmbeddedView(null);
            var factory = this.resolver.resolveComponentFactory(InputfileComponent);
            var component = this.vcRef.createComponent(factory, 0, this.injector, [_contentViewRef.rootNodes]);
            component.instance.options = (this.ngxInputFile) ? this.ngxInputFile : ngxInputFileOptions;
            _contentViewRef.detectChanges();
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxInputFileDirective.prototype, "ngxInputFile", void 0);
        NgxInputFileDirective = __decorate([
            core.Directive({
                selector: '[ngxInputFile]'
            }),
            __metadata("design:paramtypes", [core.ComponentFactoryResolver, core.Injector,
                core.ViewContainerRef, core.TemplateRef])
        ], NgxInputFileDirective);
        return NgxInputFileDirective;
    }());

    var ngxDeclarations = [
        NgxDragAndDropDirective, NgxThumbnailDirective, InputfileComponent, NgxInputFileDirective
    ];
    /**
     * Factory associated with internal logger
     * @param options
     * @returns {any}
     * @private
     */
    function _loggerFactory(options) {
        var enabled = options.enabled ? options.enabled : core.isDevMode();
        if (enabled) {
            var _console = typeof console === 'object' ? console : {};
            var debug = options.debug ? options.debug : true;
            return new ConsoleLogger(_console, debug);
        }
        return new NoOpLogger();
    }
    var NGX_UPLOAD_ROOT_GUARD = new core.InjectionToken('Internal forRoot Guard');
    function createNgxUploadRootGuard(options) {
        if (options) {
            throw new TypeError('NgxUploadModule.forRoot() is called twice.');
        }
        return 'guarded';
    }
    var NgxUploadModule = /** @class */ (function () {
        function NgxUploadModule() {
        }
        NgxUploadModule_1 = NgxUploadModule;
        NgxUploadModule.forRoot = function (dropTargetOptions, loggerOptions) {
            return {
                ngModule: NgxUploadModule_1,
                providers: [
                    { provide: NGX_LOGGER_OPTIONS, useValue: (loggerOptions) ? loggerOptions : ngxloggerOptions },
                    {
                        provide: NGX_DROP_TARGET_OPTIONS,
                        useValue: (dropTargetOptions) ? dropTargetOptions : ngxDropTargetOptions
                    },
                    {
                        provide: NgxUploadLogger,
                        useFactory: _loggerFactory,
                        deps: [NGX_LOGGER_OPTIONS]
                    },
                    {
                        provide: NGX_UPLOAD_ROOT_GUARD,
                        useFactory: createNgxUploadRootGuard,
                        deps: [[NGX_LOGGER_OPTIONS, new core.Optional(), new core.SkipSelf()]]
                    }
                ]
            };
        };
        var NgxUploadModule_1;
        NgxUploadModule = NgxUploadModule_1 = __decorate([
            core.NgModule({
                declarations: __spread(ngxDeclarations),
                exports: __spread(ngxDeclarations),
                imports: [http.HttpClientModule],
                entryComponents: [InputfileComponent]
            })
        ], NgxUploadModule);
        return NgxUploadModule;
    }());

    exports.FileItem = FileItem;
    exports.HttpClientUploadService = HttpClientUploadService;
    exports.NgxUploadModule = NgxUploadModule;
    exports.ɵa = NGX_DROP_TARGET_OPTIONS;
    exports.ɵb = NGX_LOGGER_OPTIONS;
    exports.ɵc = ngxDropTargetOptions;
    exports.ɵd = ngxloggerOptions;
    exports.ɵe = _loggerFactory;
    exports.ɵf = NGX_UPLOAD_ROOT_GUARD;
    exports.ɵg = createNgxUploadRootGuard;
    exports.ɵh = NgxUploadLogger;
    exports.ɵi = NgxDragAndDropDirective;
    exports.ɵj = NgxThumbnailDirective;
    exports.ɵk = InputfileComponent;
    exports.ɵl = NgxInputFileDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=wkoza-ngx-upload.umd.js.map
