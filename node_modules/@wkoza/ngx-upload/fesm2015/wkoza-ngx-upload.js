import { __decorate, __metadata, __param } from 'tslib';
import { Subject } from 'rxjs';
import { HttpRequest, HttpEventType, HttpResponse, HttpErrorResponse, HttpClient, HttpClientModule } from '@angular/common/http';
import { ɵɵdefineInjectable, ɵɵinject, Injectable, InjectionToken, Input, Directive, Inject, Optional, PLATFORM_ID, ElementRef, Renderer2, Injector, ViewChild, Component, ComponentFactoryResolver, ViewContainerRef, TemplateRef, isDevMode, SkipSelf, NgModule } from '@angular/core';
import { NgForm, FormGroupDirective } from '@angular/forms';
import { isPlatformBrowser } from '@angular/common';

class FileItem {
    constructor(file, uploadService, logger, disableMultipart) {
        this.file = file;
        this.uploadService = uploadService;
        this.logger = logger;
        this.disableMultipart = disableMultipart;
        this.isReady = true;
        this.progress = 0;
        this.formData = new FormData();
        this.alias = 'file';
    }
    upload(endpoint, options) {
        if (endpoint) {
            this.uploadService.uploadFileItem(this, endpoint, options);
        }
        else {
            this.logger.error('You must define a UploadEndPoint object.');
        }
    }
    cancel() {
        this.logger.debug('upload cancel');
        if (this.uploadInProgress) {
            this.ɵonCancel();
            this.uploadService.cancelFileItem(this);
        }
    }
    remove() {
        this.logger.debug('upload remove');
        this.uploadService.removeFromQueue(this);
    }
    ɵonBeforeUploadItem() {
        this.isReady = true;
        this.uploadInProgress = false;
        this.isSuccess = false;
        this.isCancel = false;
        this.isError = false;
        this.progress = 0;
    }
    ɵonProgress(progress) {
        this.isReady = false;
        this.progress = progress;
    }
    ɵonSuccess() {
        this.isReady = false;
        this.uploadInProgress = false;
        this.isSuccess = true;
        this.isCancel = false;
        this.isError = false;
        this.progress = 100;
    }
    ɵonError() {
        this.isReady = false;
        this.uploadInProgress = false;
        this.isSuccess = false;
        this.isCancel = false;
        this.isError = true;
        this.progress = 0;
    }
    ɵonCancel() {
        this.isReady = true;
        this.uploadInProgress = false;
        this.isSuccess = false;
        this.isCancel = true;
        this.isError = false;
        this.progress = 0;
        this.sub.unsubscribe();
    }
}

/**
 * Simple service for logging the module.
 */
class NgxUploadLogger {
}
const noop = () => undefined;
/**
 * Default implementation of Logger that safely writes the message into the console.
 *
 */
class ConsoleLogger {
    constructor(_console, _debugEnabled = true) {
        this._console = _console;
        this._debugEnabled = _debugEnabled;
    }
    log(...args) { this._invokeConsoleMethod('log', args); }
    info(...args) { this._invokeConsoleMethod('info', args); }
    warn(...args) { this._invokeConsoleMethod('warn', args); }
    error(...args) { this._invokeConsoleMethod('error', args); }
    debug(...args) {
        if (this._debugEnabled) {
            this._invokeConsoleMethod('debug', args);
        }
    }
    _invokeConsoleMethod(type, args) {
        let logFn = this._console[type] || this._console.log || noop;
        // console methods in IE9 don't have 'apply' method, polyfill it
        if (!logFn.apply) {
            logFn = Function.prototype.bind.call(logFn, this._console);
        }
        logFn.apply(this._console, args);
    }
}
/**
 * No op implementation of Logger.
 *
 */
class NoOpLogger {
    log() { }
    info() { }
    warn() { }
    error() { }
    debug() { }
}

// send an event for each upload event. These events can be catched by the user for call a callback
let HttpClientUploadService = class HttpClientUploadService {
    constructor(logger, httpClient) {
        this.logger = logger;
        this.httpClient = httpClient;
        this.progressTotal = 0;
        this.onCancel$ = new Subject();
        this.onError$ = new Subject();
        this.onDropError$ = new Subject();
        this.onSuccess$ = new Subject(); // TODO headers isn't `any` but `Array`
        this.onBeforeUploadItem$ = new Subject();
        this.onProgress$ = new Subject();
        this.onAddToQueue$ = new Subject();
        this.queue = new Array();
        this.headers = new Map();
    }
    /**
     * Adds files to the queue
     */
    addToQueue(files, formGroup, options) {
        this.logger.info('add to queue');
        if (options && !options.multiple) {
            if (files.length > 1) {
                this.logger.error('there is more than one file.');
                this.onDropError$.next({ errorAccept: false, errorMultiple: true });
                return;
            }
        }
        for (let i = 0; i < files.length; i++) {
            const file = files.item(i);
            this.logger.debug(files.item(i));
            if (options && options.accept) {
                const accepted = options.accept.some((type) => {
                    if (type.indexOf('/*') > -1) {
                        return type.split('/')[0] === file.type.split('/')[0];
                    }
                    else {
                        return (type === '*' || type === file.type);
                    }
                });
                if (!accepted) {
                    this.logger.error('this file is not accepted because of its type', file);
                    this.onDropError$.next({ item: file, errorAccept: true, errorMultiple: false });
                    continue;
                }
            }
            let fileItem;
            if (options && options.disableMultipart) {
                fileItem = new FileItem(file, this, this.logger, true);
            }
            else {
                fileItem = new FileItem(file, this, this.logger, false);
                if (formGroup) {
                    Object.keys(formGroup.controls).forEach((key) => {
                        fileItem.formData.append(key, formGroup.get(key).value);
                    });
                }
            }
            this.queue.push(fileItem);
            this.onAddToQueue$.next(fileItem);
        }
    }
    uploadFileItem(fileItem, endpoint, options = {}) {
        this.logger.info('enter uploadService.uploadFileItem()');
        const method = endpoint.method;
        const url = endpoint.url;
        const index = this.queue.indexOf(fileItem);
        const item = this.queue[index];
        this.onBeforeUploadItem(item);
        if (item.isCancel) {
            return;
        }
        item.uploadInProgress = true;
        let sendable;
        if (!fileItem.disableMultipart) {
            sendable = item.formData;
            sendable.append(item.alias, item.file, item.file.name);
        }
        else {
            sendable = item.file;
        }
        const req = new HttpRequest(method, url, sendable, Object.assign(options, { reportProgress: true }));
        fileItem.sub = this.httpClient.request(req).subscribe((event) => {
            if (event.type === HttpEventType.UploadProgress) {
                // This is an upload progress event. Compute and show the % done:
                const percentDone = Math.round(event.loaded * 100 / (event.total ? event.total : event.loaded));
                this.logger.debug(`File is ${percentDone}% uploaded.`);
                fileItem.ɵonProgress(percentDone);
                this.onProgressItem(item, percentDone);
            }
            else if (event instanceof HttpResponse) {
                // A successful response is delivered on the event stream.
                fileItem.ɵonSuccess();
                this.onSuccess(item, event.body, event.status, event.headers);
            }
        }, (err) => {
            if (err instanceof HttpErrorResponse) {
                if (url === 'ngx_upload_mock') {
                    item.ɵonSuccess();
                    this.onSuccess(item, err.message, err.status, err.headers);
                }
                else if (err.error instanceof Error) {
                    // A client-side or network error occurred. Handle it accordingly.
                    item.ɵonError();
                    this.onError(item, err.error.message, err.status, err.headers);
                }
                else {
                    // The backend returned an unsuccessful response code.
                    // The response body may contain clues as to what went wrong,
                    item.ɵonError();
                    this.onError(item, err.error, err.status, err.headers);
                }
            }
        });
    }
    cancelFileItem(fileItem) {
        this.progressTotal = this.computeTotalProgress();
        this.onCancel$.next(fileItem);
    }
    /**
     * Uploads all not uploaded items of queue
     */
    uploadAll(endpoint, options) {
        const items = this.queue.filter(item => (item.isReady));
        if (!items.length) {
            return;
        }
        for (const item of items) {
            item.upload(endpoint, options);
        }
    }
    /**
     * Uploads all not uploaded items of queue
     */
    cancelAll() {
        const items = this.queue.filter(item => (item.uploadInProgress));
        if (!items.length) {
            return;
        }
        for (const item of items) {
            item.cancel();
        }
        this.progressTotal = this.computeTotalProgress();
    }
    /**
     * Uploads all not uploaded items of queue
     */
    removeAllFromQueue() {
        const items = this.queue.filter(item => (!item.uploadInProgress && !item.isSuccess));
        if (!items.length) {
            return;
        }
        for (const item of items) {
            this.removeFromQueue(item);
        }
    }
    removeFromQueue(fileItem) {
        const index = this.queue.indexOf(fileItem);
        const item = this.queue[index];
        if (item.uploadInProgress) {
            item.cancel();
        }
        this.queue.splice(index, 1);
        this.progressTotal = this.computeTotalProgress();
    }
    /**
     * Returns the total progress
     * @param {Number} [value]
     * @returns {Number}
     * @private
     */
    computeTotalProgress() {
        let totalCurrent = 0;
        let total = 0;
        for (const item of this.queue) {
            if (item.uploadInProgress || item.isSuccess) {
                totalCurrent += (item.file.size / 100) * item.progress || 0;
                total += item.file.size;
                this.logger.debug(totalCurrent + ' / ' + total);
            }
        }
        return Math.round((totalCurrent * 100) / total);
    }
    /**
     * Prepares file status before upload
     * @param item
     */
    onBeforeUploadItem(item) {
        this.logger.info('enter uploadService.ɵonBeforeUploadItem()');
        item.ɵonBeforeUploadItem();
        this.onBeforeUploadItem$.next(item);
    }
    /**
     * Update status during upload progress
     * @param item
     * @param progress
     */
    onProgressItem(item, progress) {
        this.logger.info(`call onProgressItem ${item} ${progress}`);
        this.progressTotal = this.computeTotalProgress();
        item.ɵonProgress(progress);
        this.onProgress$.next({ item, progress });
    }
    /**
     * Callback called when an upload error occurs
     * @param item
     * @param xhr
     */
    onError(item, body, status, headers) {
        this.logger.info(`call onError ${item} ${body} ${status} ${headers}`);
        item.ɵonError();
        this.onError$.next({ item, body, status, headers });
    }
    /**
     * Callback called when an upload success occurs
     * @param item
     * @param xhr
     */
    onSuccess(item, body, status, headers) {
        this.logger.info(`call onSuccess ${item} ${body} ${status} ${headers}`);
        this.progressTotal = this.computeTotalProgress();
        item.ɵonSuccess();
        this.onSuccess$.next({ item, body, status, headers });
    }
};
HttpClientUploadService.ngInjectableDef = ɵɵdefineInjectable({ factory: function HttpClientUploadService_Factory() { return new HttpClientUploadService(ɵɵinject(NgxUploadLogger), ɵɵinject(HttpClient)); }, token: HttpClientUploadService, providedIn: "root" });
HttpClientUploadService = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __metadata("design:paramtypes", [NgxUploadLogger, HttpClient])
], HttpClientUploadService);

const NGX_DROP_TARGET_OPTIONS = new InjectionToken('Ngx drop Zone Options');
const NGX_LOGGER_OPTIONS = new InjectionToken('Ngx Logger Options');
const ngxDropTargetOptions = {
    color: '',
    colorDrag: '',
    colorDrop: '',
    multiple: true,
    disableMultipart: false
};
const ngxloggerOptions = {
    enabled: false,
    debug: true
};
const ngxInputFileOptions = {
    multiple: true,
    disableMultipart: false
};

/**
 * Transforms a node into a drag and drop zone.
 */
let NgxDragAndDropDirective = class NgxDragAndDropDirective {
    constructor(el, renderer, injector, logger, uploader, dropOptions, ngForm, formGroupDirective, platformId) {
        this.el = el;
        this.renderer = renderer;
        this.injector = injector;
        this.logger = logger;
        this.uploader = uploader;
        this.dropOptions = dropOptions;
        this.ngForm = ngForm;
        this.formGroupDirective = formGroupDirective;
        if (this.ngForm) {
            this.formGroup = ngForm.form;
        }
        else if (this.formGroupDirective) {
            this.formGroup = formGroupDirective.form;
        }
        else {
            this.formGroup = null;
        }
        if (isPlatformBrowser(platformId)) {
            this.renderer.listen(el.nativeElement, 'dragleave', ($event) => this.onDragLeave($event));
            this.renderer.listen(el.nativeElement, 'drop', ($event) => this.dropEvent($event));
            this.renderer.listen(el.nativeElement, 'dragover', ($event) => this.onDragOver($event));
        }
    }
    set ngxDragAndDrop(dropOptions) {
        if (dropOptions) {
            this.logger.debug(JSON.stringify(dropOptions));
            this.dropOptions = dropOptions;
        }
    }
    ngOnInit() {
        this.renderer.addClass(this.el.nativeElement, this.dropOptions.color);
    }
    onDragLeave(event) {
        this.logger.debug('dragleave event');
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrag);
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrop);
        this.renderer.addClass(this.el.nativeElement, this.dropOptions.color);
        this.stopAndPrevent(event);
    }
    dropEvent(event) {
        this.logger.debug('drop event');
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.color);
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrag);
        this.renderer.addClass(this.el.nativeElement, this.dropOptions.colorDrop);
        const transfer = this.getTransfer(event);
        if (!transfer) {
            return;
        }
        transfer.dropEffect = 'copy';
        this.stopAndPrevent(event);
        this.uploader.addToQueue(transfer.files, this.formGroup, this.dropOptions);
    }
    onDragOver(event) {
        this.logger.debug('dragover event');
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.color);
        this.renderer.removeClass(this.el.nativeElement, this.dropOptions.colorDrop);
        this.renderer.addClass(this.el.nativeElement, this.dropOptions.colorDrag);
        const transfer = this.getTransfer(event);
        if (!this.haveFiles(transfer.types)) {
            return;
        }
        this.stopAndPrevent(event);
    }
    stopAndPrevent(event) {
        event.stopPropagation();
        event.preventDefault();
    }
    getTransfer(event) {
        return event.dataTransfer ? event.dataTransfer : event.originalEvent.dataTransfer;
    }
    haveFiles(types) {
        if (!types) {
            return false;
        }
        if (types.indexOf) {
            return types.indexOf('Files') !== -1;
        }
        else if (types.contains) {
            return types.contains('Files');
        }
        else {
            return false;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], NgxDragAndDropDirective.prototype, "ngxDragAndDrop", null);
NgxDragAndDropDirective = __decorate([
    Directive({
        selector: '[ngxDragAndDrop]',
        exportAs: 'ngxDragAndDrop'
    }),
    __param(5, Inject(NGX_DROP_TARGET_OPTIONS)),
    __param(6, Optional()), __param(7, Optional()),
    __param(8, Inject(PLATFORM_ID)),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        Injector,
        NgxUploadLogger,
        HttpClientUploadService, Object, NgForm, FormGroupDirective,
        Object])
], NgxDragAndDropDirective);

/**
 * Transforms a node into a thumbnail zone.
 */
let NgxThumbnailDirective = class NgxThumbnailDirective {
    constructor(renderer, el) {
        this.renderer = renderer;
        this.el = el;
    }
    ngOnInit() {
        // must be used only with image file
        if (this.fileItem.file.type.indexOf('image/jpeg') !== 0 &&
            this.fileItem.file.type.indexOf('image/png') !== 0) {
            return;
        }
        else {
            const imgEl = this.renderer.createElement('img');
            this.renderer.appendChild(this.el.nativeElement, imgEl);
            this.renderer.setStyle(imgEl, 'width', '100%');
            this.renderer.setStyle(imgEl, 'height', '100%');
            this._getOrientation(this.fileItem.file, (srcOrientation) => {
                const img = new Image();
                const reader = new FileReader();
                reader.onload = (evt) => {
                    img.onload = () => {
                        const width = img.width, height = img.height, canvas = document.createElement('canvas'), ctx = canvas.getContext('2d');
                        // set proper canvas dimensions before transform & export
                        if (4 < srcOrientation && srcOrientation < 9) {
                            canvas.width = height;
                            canvas.height = width;
                        }
                        else {
                            canvas.width = width;
                            canvas.height = height;
                        }
                        // transform context before drawing image
                        switch (srcOrientation) {
                            case 2:
                                ctx.transform(-1, 0, 0, 1, width, 0);
                                break;
                            case 3:
                                ctx.transform(-1, 0, 0, -1, width, height);
                                break;
                            case 4:
                                ctx.transform(1, 0, 0, -1, 0, height);
                                break;
                            case 5:
                                ctx.transform(0, 1, 1, 0, 0, 0);
                                break;
                            case 6:
                                ctx.transform(0, 1, -1, 0, height, 0);
                                break;
                            case 7:
                                ctx.transform(0, -1, -1, 0, height, width);
                                break;
                            case 8:
                                ctx.transform(0, -1, 1, 0, 0, width);
                                break;
                            default:
                                break;
                        }
                        // draw image
                        ctx.drawImage(img, 0, 0);
                        this.renderer.setProperty(imgEl, 'src', canvas.toDataURL());
                    };
                    img.src = evt.target['result'];
                };
                reader.readAsDataURL(this.fileItem.file);
            });
        }
    }
    /*
    * getOrientation computes the real orientation of the image
    *
    */
    _getOrientation(file, callback) {
        const reader = new FileReader();
        reader.onload = (event) => {
            const view = new DataView(event.target['result']);
            if (view.getUint16(0, false) !== 0xFFD8)
                return callback(-2);
            const length = view.byteLength;
            let offset = 2;
            while (offset < length) {
                const marker = view.getUint16(offset, false);
                offset += 2;
                if (marker === 0xFFE1) {
                    if (view.getUint32(offset += 2, false) !== 0x45786966) {
                        return callback(-1);
                    }
                    const little = view.getUint16(offset += 6, false) === 0x4949;
                    offset += view.getUint32(offset + 4, little);
                    const tags = view.getUint16(offset, little);
                    offset += 2;
                    for (let i = 0; i < tags; i++)
                        if (view.getUint16(offset + (i * 12), little) === 0x0112)
                            return callback(view.getUint16(offset + (i * 12) + 8, little));
                }
                else if ((marker & 0xFF00) !== 0xFF00)
                    break;
                else
                    offset += view.getUint16(offset, false);
            }
            return callback(-1);
        };
        reader.readAsArrayBuffer(file.slice(0, 64 * 1024));
    }
    ;
};
__decorate([
    Input('ngxThumbnail'),
    __metadata("design:type", FileItem)
], NgxThumbnailDirective.prototype, "fileItem", void 0);
NgxThumbnailDirective = __decorate([
    Directive({
        selector: '[ngxThumbnail]',
        exportAs: 'ngxThumbnail'
    }),
    __metadata("design:paramtypes", [Renderer2, ElementRef])
], NgxThumbnailDirective);

let InputfileComponent = class InputfileComponent {
    constructor(injector, uploader, renderer, ngForm, formGroupDirective) {
        this.injector = injector;
        this.uploader = uploader;
        this.renderer = renderer;
        this.ngForm = ngForm;
        this.formGroupDirective = formGroupDirective;
        this.files = new Set();
        if (this.ngForm) {
            this.formGroup = ngForm.form;
        }
        else if (this.formGroupDirective) {
            this.formGroup = formGroupDirective.form;
        }
        else {
            this.formGroup = null;
        }
    }
    onFilesAdded() {
        this.uploader.addToQueue(this.file.nativeElement.files, this.formGroup, this.options);
        // Clear the previous input value
        this.file.nativeElement.value = '';
    }
    ngAfterViewInit() {
        if (this.options.multiple !== false)
            this.renderer.setProperty(this.file.nativeElement, 'multiple', 'multiple');
        if (this.options.accept)
            this.renderer.setProperty(this.file.nativeElement, 'accept', this.options.accept.join());
        if (this.options.capture)
            this.renderer.setProperty(this.file.nativeElement, 'capture', this.options.capture);
    }
};
__decorate([
    ViewChild('file', { static: true }),
    __metadata("design:type", Object)
], InputfileComponent.prototype, "file", void 0);
InputfileComponent = __decorate([
    Component({
        selector: 'ngx-upload-inputfile',
        template: `
      <label class="input-file">
          <input type="file" #file (change)="onFilesAdded()">
          <ng-content></ng-content>
      </label>`,
        styles: ['input[type="file"] { display: none; } .input-file { width: 100%; }']
    }),
    __param(3, Optional()), __param(4, Optional()),
    __metadata("design:paramtypes", [Injector, HttpClientUploadService, Renderer2,
        NgForm, FormGroupDirective])
], InputfileComponent);

let NgxInputFileDirective = class NgxInputFileDirective {
    constructor(resolver, injector, vcRef, templateRef) {
        this.resolver = resolver;
        this.injector = injector;
        this.vcRef = vcRef;
        this.templateRef = templateRef;
    }
    ngOnInit() {
        const _contentViewRef = this.templateRef.createEmbeddedView(null);
        const factory = this.resolver.resolveComponentFactory(InputfileComponent);
        const component = this.vcRef.createComponent(factory, 0, this.injector, [_contentViewRef.rootNodes]);
        component.instance.options = (this.ngxInputFile) ? this.ngxInputFile : ngxInputFileOptions;
        _contentViewRef.detectChanges();
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxInputFileDirective.prototype, "ngxInputFile", void 0);
NgxInputFileDirective = __decorate([
    Directive({
        selector: '[ngxInputFile]'
    }),
    __metadata("design:paramtypes", [ComponentFactoryResolver, Injector,
        ViewContainerRef, TemplateRef])
], NgxInputFileDirective);

var NgxUploadModule_1;
const ngxDeclarations = [
    NgxDragAndDropDirective, NgxThumbnailDirective, InputfileComponent, NgxInputFileDirective
];
/**
 * Factory associated with internal logger
 * @param options
 * @returns {any}
 * @private
 */
function _loggerFactory(options) {
    const enabled = options.enabled ? options.enabled : isDevMode();
    if (enabled) {
        const _console = typeof console === 'object' ? console : {};
        const debug = options.debug ? options.debug : true;
        return new ConsoleLogger(_console, debug);
    }
    return new NoOpLogger();
}
const NGX_UPLOAD_ROOT_GUARD = new InjectionToken('Internal forRoot Guard');
function createNgxUploadRootGuard(options) {
    if (options) {
        throw new TypeError('NgxUploadModule.forRoot() is called twice.');
    }
    return 'guarded';
}
let NgxUploadModule = NgxUploadModule_1 = class NgxUploadModule {
    static forRoot(dropTargetOptions, loggerOptions) {
        return {
            ngModule: NgxUploadModule_1,
            providers: [
                { provide: NGX_LOGGER_OPTIONS, useValue: (loggerOptions) ? loggerOptions : ngxloggerOptions },
                {
                    provide: NGX_DROP_TARGET_OPTIONS,
                    useValue: (dropTargetOptions) ? dropTargetOptions : ngxDropTargetOptions
                },
                {
                    provide: NgxUploadLogger,
                    useFactory: _loggerFactory,
                    deps: [NGX_LOGGER_OPTIONS]
                },
                {
                    provide: NGX_UPLOAD_ROOT_GUARD,
                    useFactory: createNgxUploadRootGuard,
                    deps: [[NGX_LOGGER_OPTIONS, new Optional(), new SkipSelf()]]
                }
            ]
        };
    }
    ;
};
NgxUploadModule = NgxUploadModule_1 = __decorate([
    NgModule({
        declarations: [
            ...ngxDeclarations
        ],
        exports: [
            ...ngxDeclarations
        ],
        imports: [HttpClientModule],
        entryComponents: [InputfileComponent]
    })
], NgxUploadModule);

export { FileItem, HttpClientUploadService, NgxUploadModule, NGX_DROP_TARGET_OPTIONS as ɵa, NGX_LOGGER_OPTIONS as ɵb, ngxDropTargetOptions as ɵc, ngxloggerOptions as ɵd, _loggerFactory as ɵe, NGX_UPLOAD_ROOT_GUARD as ɵf, createNgxUploadRootGuard as ɵg, NgxUploadLogger as ɵh, NgxDragAndDropDirective as ɵi, NgxThumbnailDirective as ɵj, InputfileComponent as ɵk, NgxInputFileDirective as ɵl };
//# sourceMappingURL=wkoza-ngx-upload.js.map
